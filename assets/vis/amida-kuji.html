<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fixed Amidakuji Game</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <style>
        body {
            font-family: 'Comic Sans MS', cursive;
            background-color: #1a1a1a;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .button-row {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        button {
            margin: 5px;
            padding: 10px 20px;
            background-color: #FF69B4;
            color: white;
            border: none;
            cursor: pointer;
            font-family: 'Comic Sans MS', cursive;
            font-size: 16px;
            border-radius: 25px;
            transition: all 0.3s;
        }
        button:hover {
            background-color: #FF1493;
            transform: scale(1.05);
        }
        #result {
            margin-top: 10px;
            font-size: 24px;
        }
        .explanation {
            max-width: 600px;
            text-align: center;
            margin-bottom: 20px;
            font-size: 18px;
        }
        .emoji {
            font-size: 24px;
        }
    </style>
</head>
<body>
    <h1>üé≤ Ladder Lottery üé≤</h1>
    <div class="explanation">
        Ladder Lottery is a fun East Asian game, also known as "È¨ºËÖ≥Âúñ" (Guijiaotu) in China, "ÈòøÂº•ÈôÄÁ±§" (Amida-kuzi) in Japan, "ÏÇ¨Îã§Î¶¨ÌÉÄÍ∏∞" (Sadaritagi) in Korea.
        Click on a fruit emoji at the top to choose a path and see where you end up! üöÄ
        Your path will be shown in yellow, and the winning path in red.
        You can change the winning position by clicking on the bottom flags. Can you find the lucky path? üçÄ
    </div>
    <div id="game-container">
        <div>
            <label for="lines">Number of horizontal lines: </label>
            <input type="range" id="lines" min="5" max="500" value="10">
            <span id="lines-value">10</span>
        </div>
        <div class="button-row">
            <button id="auto-play">ü§ñ Play 1000 Times</button>
            <button id="reset-stats">üîÑ Reset Statistics</button>
        </div>
        <div class="button-row">
            <button id="reveal-trophy">üèÜ Reveal the Trophy</button>
        </div>
        <div id="stats"></div>
        <div id="amidakuji"></div>
        <div id="result"></div>
    </div>

    <script>
        // Configuration constants
        const CONFIG = {
            width: 480,
            height: 400,
            margin: { top: 40, right: 10, bottom: 40, left: 10 },
            numPaths: 7,
            minRungSpacing: 20,
            stepSize: 2,
            detectionTolerance: 3
        };

        const gameWidth = CONFIG.width - CONFIG.margin.left - CONFIG.margin.right;
        const gameHeight = CONFIG.height - CONFIG.margin.top - CONFIG.margin.bottom;

        const svg = d3.select("#amidakuji")
            .append("svg")
            .attr("width", CONFIG.width)
            .attr("height", CONFIG.height);

        const gameArea = svg.append("g")
            .attr("transform", `translate(${CONFIG.margin.left},${CONFIG.margin.top})`);

        let horizontalLines = [];
        let cellWidth, cellHeight;
        let gameState = 'ready';
        let currentPath = [];
        let winningStats = [0, 0, 0, 0, 0, 0, 0];
        let winningColumn = 5;
        let totalGames = 0;
        let trophyVisible = false;

        const linesSlider = document.getElementById('lines');
        const linesValue = document.getElementById('lines-value');
        const autoPlayButton = document.getElementById('auto-play');
        const resetStatsButton = document.getElementById('reset-stats');
        const revealTrophyButton = document.getElementById('reveal-trophy');
        const resultDiv = document.getElementById('result');

        const emojis = ['üçé', 'üçå', 'üçá', 'üçä', 'üçì', 'üçâ', 'üçç'];
        const flagEmoji = 'üö©';
        const trophyEmoji = 'üèÜ';

        function initGame() {
            gameState = 'ready';
            resultDiv.textContent = '';
            generateHorizontalLines();
            calculateWinningStart();
            totalGames++;
            drawGame();
            updateStats();
        }

        function generateHorizontalLines() {
            horizontalLines = [];
            const lineCount = parseInt(linesSlider.value);

            for (let i = 0; i < lineCount; i++) {
                // Rungs connect adjacent lines x to x+1, so x ranges from 0 to numPaths-2
                const x = Math.floor(Math.random() * (CONFIG.numPaths - 1));
                const y = (i + 1) / (lineCount + 1);
                horizontalLines.push({ x: x, y: y });
            }

            // Sort by Y position for correct processing
            horizontalLines.sort((a, b) => a.y - b.y);
        }

        function calculateWinningStart() {
            let x = winningColumn;
            for (let i = horizontalLines.length - 1; i >= 0; i--) {
                if (x === horizontalLines[i].x + 1) {
                    x--;
                } else if (x === horizontalLines[i].x) {
                    x++;
                }
            }
            winningStats[x]++;
        }

        function drawGame() {
            gameArea.selectAll("*").remove();

            cellWidth = gameWidth / CONFIG.numPaths;
            cellHeight = gameHeight / (horizontalLines.length + 2);

            // Draw vertical lines
            for (let i = 0; i < CONFIG.numPaths; i++) {
                gameArea.append("line")
                    .attr("x1", i * cellWidth)
                    .attr("y1", 0)
                    .attr("x2", i * cellWidth)
                    .attr("y2", gameHeight)
                    .attr("stroke", "#ffffff")
                    .attr("stroke-width", 2);
            }

            // Draw horizontal lines
            horizontalLines.forEach(line => {
                const y = line.y * gameHeight;
                gameArea.append("line")
                    .attr("x1", line.x * cellWidth)
                    .attr("y1", y)
                    .attr("x2", (line.x + 1) * cellWidth)
                    .attr("y2", y)
                    .attr("stroke", "#ffffff")
                    .attr("stroke-width", 2);
            });

            // Draw clickable path selectors at the top
            for (let i = 0; i < CONFIG.numPaths; i++) {
                gameArea.append("text")
                    .attr("x", i * cellWidth)
                    .attr("y", -10)
                    .attr("text-anchor", "middle")
                    .attr("fill", "#ffffff")
                    .attr("font-size", "24px")
                    .text(emojis[i])
                    .on("click", () => handleClick(i))
                    .style("cursor", "pointer");
            }

            // Draw clickable winner selectors and trophies at the bottom
            for (let i = 0; i < CONFIG.numPaths; i++) {
                gameArea.append("text")
                    .attr("x", i * cellWidth)
                    .attr("y", gameHeight + 30)
                    .attr("text-anchor", "middle")
                    .attr("fill", i === winningColumn ? "#FFD700" : "#ffffff")
                    .attr("font-size", "24px")
                    .text(flagEmoji)
                    .on("click", () => setWinningColumn(i))
                    .style("cursor", "pointer");

                if (i === winningColumn && trophyVisible) {
                    gameArea.append("text")
                        .attr("x", i * cellWidth)
                        .attr("y", gameHeight + 20)
                        .attr("text-anchor", "middle")
                        .attr("fill", "#FFD700")
                        .attr("font-size", "32px")
                        .text(trophyEmoji);
                }
            }
        }

        function setWinningColumn(column) {
            winningColumn = column;
            initGame();
        }

        function drawPath(column, color) {
            let x = column;
            let currentYPixel = 0;
            let rungIndex = 0;

            const path = d3.path();
            path.moveTo(x * cellWidth, 0);

            // Process rungs in order
            while (currentYPixel <= gameHeight && rungIndex < horizontalLines.length) {
                const nextRung = horizontalLines[rungIndex];
                const nextRungY = nextRung.y * gameHeight;

                // Move to the rung's Y position
                if (currentYPixel < nextRungY) {
                    currentYPixel = nextRungY;
                    path.lineTo(x * cellWidth, currentYPixel);
                }

                // Check if we're on this rung
                if (x === nextRung.x) {
                    x++;
                    path.lineTo(x * cellWidth, currentYPixel);
                } else if (x === nextRung.x + 1) {
                    x--;
                    path.lineTo(x * cellWidth, currentYPixel);
                }

                rungIndex++;
            }

            // Draw to bottom
            path.lineTo(x * cellWidth, gameHeight);

            gameArea.append("path")
                .attr("d", path.toString())
                .attr("fill", "none")
                .attr("stroke", color)
                .attr("stroke-width", 3);

            return x;
        }

        function handleClick(column) {
            if (gameState !== 'ready') return;

            gameState = 'drawing';
            const userEndColumn = drawPath(column, "yellow");
            const winningStartColumn = winningStats.indexOf(Math.max(...winningStats));
            drawPath(winningStartColumn, "red");

            setTimeout(() => {
                checkResult(column, userEndColumn);
            }, 500);
        }

        function checkResult(startColumn, endColumn) {
            if (endColumn === winningColumn) {
                resultDiv.innerHTML = `${emojis[startColumn]} Path ${startColumn} is a winner! üéâ Congratulations! üéä`;
            } else {
                resultDiv.innerHTML = `${emojis[startColumn]} Path ${startColumn} is not a winner. üò¢ Try again! üçÄ`;
            }
            updateStats();
            setTimeout(initGame, 1500);
        }

        function updateStats() {
            const data = winningStats.map((value, index) => ({
                path: index,
                count: value,
                percentage: totalGames > 0 ? (value / totalGames) * 100 : 0
            }));

            d3.select("#stats").selectAll("*").remove();

            const statsWidth = 480;
            const statsHeight = 220;
            const statsMargin = { top: 40, right: 20, bottom: 30, left: 40 };
            const chartWidth = statsWidth - statsMargin.left - statsMargin.right;
            const chartHeight = statsHeight - statsMargin.top - statsMargin.bottom;

            const statsSvg = d3.select("#stats")
                .append("svg")
                .attr("width", statsWidth)
                .attr("height", statsHeight)
                .append("g")
                .attr("transform", `translate(${statsMargin.left},${statsMargin.top})`);

            const x = d3.scaleBand()
                .range([0, chartWidth])
                .padding(0.1);

            const y = d3.scaleLinear()
                .range([chartHeight, 0]);

            x.domain(data.map(d => d.path));
            const maxPercentage = d3.max(data, d => d.percentage);
            y.domain([0, maxPercentage > 0 ? maxPercentage : 100]);

            statsSvg.selectAll(".bar")
                .data(data)
                .enter().append("rect")
                .attr("class", "bar")
                .attr("x", d => x(d.path))
                .attr("width", x.bandwidth())
                .attr("y", d => y(d.percentage))
                .attr("height", d => chartHeight - y(d.percentage))
                .attr("fill", (d, i) => d3.schemeCategory10[i]);

            statsSvg.selectAll(".label")
                .data(data)
                .enter().append("text")
                .attr("class", "label")
                .attr("x", d => x(d.path) + x.bandwidth() / 2)
                .attr("y", d => y(d.percentage) - 5)
                .attr("text-anchor", "middle")
                .attr("fill", "#ffffff")
                .text(d => `${d.percentage.toFixed(1)}%`);

            statsSvg.append("g")
                .attr("transform", `translate(0,${chartHeight})`)
                .call(d3.axisBottom(x))
                .attr("color", "#ffffff");

            statsSvg.append("g")
                .call(d3.axisLeft(y).ticks(5).tickFormat(d => d.toFixed(1) + "%"))
                .attr("color", "#ffffff");

            statsSvg.append("text")
                .attr("x", chartWidth / 2)
                .attr("y", -20)
                .attr("text-anchor", "middle")
                .attr("fill", "#ffffff")
                .text("üèÜ Winning Path Distribution (%) üèÜ");
        }

        function autoPlay() {
            let count = 0;
            function playOne() {
                if (count < 1000) {
                    initGame();
                    const randomColumn = Math.floor(Math.random() * CONFIG.numPaths);
                    const endColumn = drawPath(randomColumn, `rgba(255, 255, 0, 0.1)`);
                    drawPath(winningColumn, `rgba(255, 0, 0, 0.1)`);
                    winningStats[randomColumn] += (endColumn === winningColumn ? 1 : 0);
                    count++;
                    if (count % 10 === 0) {
                        updateStats();
                    }
                    setTimeout(playOne, 10);
                } else {
                    updateStats();
                    resultDiv.innerHTML = '1000 random plays completed! üéâü§ñ';
                    setTimeout(initGame, 1500);
                }
            }
            playOne();
        }

        function resetStats() {
            winningStats = [0, 0, 0, 0, 0, 0, 0];
            totalGames = 0;
            updateStats();
            resultDiv.innerHTML = 'Statistics have been reset! üîÑ';
        }

        function revealTrophy() {
            trophyVisible = !trophyVisible;

            if (trophyVisible) {
                revealTrophyButton.textContent = 'üôà Hide Trophy';
                if (gameState === 'ready') {
                    const winningStartColumn = winningStats.indexOf(Math.max(...winningStats));
                    drawPath(winningStartColumn, "red");
                    resultDiv.innerHTML = `üèÜ The trophy is at position ${winningColumn}! The winning path starts from ${emojis[winningStartColumn]} (position ${winningStartColumn})`;
                }
            } else {
                revealTrophyButton.textContent = 'üèÜ Reveal the Trophy';
                resultDiv.innerHTML = '';
            }

            drawGame();
        }

        linesSlider.addEventListener('input', () => {
            linesValue.textContent = linesSlider.value;
            initGame();
        });

        autoPlayButton.addEventListener('click', autoPlay);
        resetStatsButton.addEventListener('click', resetStats);
        revealTrophyButton.addEventListener('click', revealTrophy);

        initGame();
    </script>
</body>
</html>