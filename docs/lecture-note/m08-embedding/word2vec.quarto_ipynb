{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "# word2vec\n",
        "\n",
        "In this section, we will introduce *word2vec*, a powerful technique for learning word embeddings. word2vec is a neural network model that learns words embeddings in a continuous vector space. It was introduced by Tomas Mikolov and his colleagues at Google in 2013 {footcite}`mikolov2013distributed`.\n",
        "\n",
        "## How it works\n",
        "\n",
        "\"You shall know a word by the company it keeps\" {footcite}`church1988word` is a famous quote in linguistics. It means that you can understand the meaning of a word by looking at the words that appear in the same context.\n",
        "word2vec operates on the same principle.\n",
        "word2vec identifies a word's context by examining the words within a fixed window around it. For example, in the sentence:\n",
        "\n",
        "> The quick brown fox jumps over a lazy dog\n",
        "\n",
        "The context of the word *fox* includes *quick*, *brown*, *jumps*, *over*, and *lazy*. word2vec is trained to predict which words are likely to appear as the context of an input word.\n",
        "\n",
        "```{note}\n",
        "There are two main architectures for word2vec:\n",
        "1. **Continuous Bag of Words (CBOW)**: Predicts the target word (center word) from the context words (surrounding words).\n",
        "2. **Skip-gram**: Predicts the context words (surrounding words) from the target word (center word).\n",
        "```\n",
        "\n",
        "So how are word embeddings learned? word2vec is a neural network model that looks like a bow tie. It has two layers of the vocabulary size coupled with a much smaller hidden layer.\n",
        "\n",
        "![](../figs/word2vec.png)\n",
        "\n",
        "- **Input layer**: The input layer consists of $N$ neurons, where $N$ is the size of the vocabulary (i.e., the number of unique words in the corpus). Each neuron corresponds to a unique word in the vocabulary. When a word is inputted, its corresponding neuron is activated and the other neurons are inhibited. Thus, the input layer is essentially a lookup mechanism that transforms the input word into a corresponding one-hot vector.\n",
        "\n",
        "- **Output layer**: The output layer also consists of $N$ neurons, each corresponding to a unique word in the vocabulary. Unlike the input layer, multiple neurons can be activated for a single input. The strength of the activation of each neuron (with a normalization by the softmax function) represents the probability of the corresponding word being the input word's context.\n",
        "\n",
        "- **Hidden layer**: The hidden layer is much smaller than the input and output layers. Multiple neurons in the hidden layer can be activated for a single input, and this activation pattern represents the word's *embedding*.\n",
        "\n",
        "We can consider word2vec as a *dimensionality reduction* technique that reduces the dimensionality of the input layer to the hidden layer based on the co-occurrence of words within a short distance. The distance is named the *window size*, which is a user-defined hyperparameter.\n",
        "\n",
        "## What's special about word2vec?\n",
        "\n",
        "With word2vec, words are represented as dense vectors, enabling us to explore their relationships using simple linear algebra. This is in contrast to traditional natural language processing (NLP) methods, such as bag-of-words and topic modeling, which represent words as discrete units or high-dimensional vectors.\n",
        "\n",
        "\n",
        "![](https://miro.medium.com/v2/resize:fit:678/1*5F4TXdFYwqi-BWTToQPIfg.jpeg)\n",
        "\n",
        "To showcase the effectiveness of word2vec, let's walk through an example using the `gensim` library."
      ],
      "id": "4b3f1b34"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import gensim\n",
        "import gensim.downloader\n",
        "from gensim.models import Word2Vec\n",
        "\n",
        "# Load pre-trained word2vec model from Google News\n",
        "model = gensim.downloader.load('word2vec-google-news-300')"
      ],
      "id": "5628b083",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Our first example is to find the words most similar to *king*."
      ],
      "id": "f1b404f2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Example usage\n",
        "word = \"king\"\n",
        "similar_words = model.most_similar(word)\n",
        "print(f\"Words most similar to '{word}':\")\n",
        "for similar_word, similarity in similar_words:\n",
        "    print(f\"{similar_word}: {similarity:.4f}\")"
      ],
      "id": "7c82eecd",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "A cool (yet controversial) application of word embeddings is analogy solving. Let us consider the following puzzle:\n",
        "\n",
        "> *man* is to *woman* as *king* is to ___ ?\n",
        "\n",
        "We can use word embeddings to solve this puzzle."
      ],
      "id": "d4e92960"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# We solve the puzzle by\n",
        "#\n",
        "#  vec(king) - vec(man) + vec(woman)\n",
        "#\n",
        "# To solve this, we use the model.most_similar function, with positive words being \"king\" and \"woman\" (additive), and negative words being \"man\" (subtractive).\n",
        "#\n",
        "model.most_similar(positive=['woman', \"king\"], negative=['man'], topn=5)"
      ],
      "id": "a59a0949",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The last example is to visualize the word embeddings."
      ],
      "id": "68a5b8d4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        ":tags: [hide-input]\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn as sns\n",
        "import numpy as np\n",
        "import pandas as pd\n",
        "from sklearn.decomposition import PCA\n",
        "\n",
        "countries = ['Germany', 'France', 'Italy', 'Spain', 'Portugal', 'Greece']\n",
        "capital_words = ['Berlin', 'Paris', 'Rome', 'Madrid', 'Lisbon', 'Athens']\n",
        "\n",
        "# Get the word embeddings for the countries and capitals\n",
        "country_embeddings = np.array([model[country] for country in countries])\n",
        "capital_embeddings = np.array([model[capital] for capital in capital_words])\n",
        "\n",
        "# Compute the PCA\n",
        "pca = PCA(n_components=2)\n",
        "embeddings = np.vstack([country_embeddings, capital_embeddings])\n",
        "embeddings_pca = pca.fit_transform(embeddings)\n",
        "\n",
        "# Create a DataFrame for seaborn\n",
        "df = pd.DataFrame(embeddings_pca, columns=['PC1', 'PC2'])\n",
        "df['Label'] = countries + capital_words\n",
        "df['Type'] = ['Country'] * len(countries) + ['Capital'] * len(capital_words)\n",
        "\n",
        "# Plot the data\n",
        "plt.figure(figsize=(12, 10))\n",
        "\n",
        "# Create a scatter plot with seaborn\n",
        "scatter_plot = sns.scatterplot(data=df, x='PC1', y='PC2', hue='Type', style='Type', s=200, palette='deep', markers=['o', 's'])\n",
        "\n",
        "# Annotate the points\n",
        "for i in range(len(df)):\n",
        "    plt.text(df['PC1'][i], df['PC2'][i] + 0.08, df['Label'][i], fontsize=12, ha='center', va='bottom',\n",
        "             bbox=dict(facecolor='white', edgecolor='none', alpha=0.8))\n",
        "\n",
        "# Draw arrows between countries and capitals\n",
        "for i in range(len(countries)):\n",
        "    plt.arrow(df['PC1'][i], df['PC2'][i], df['PC1'][i + len(countries)] - df['PC1'][i], df['PC2'][i + len(countries)] - df['PC2'][i],\n",
        "              color='gray', alpha=0.6, linewidth=1.5, head_width=0.02, head_length=0.03)\n",
        "\n",
        "plt.legend(title='Type', title_fontsize='13', fontsize='11')\n",
        "plt.title('PCA of Country and Capital Word Embeddings', fontsize=16)\n",
        "plt.xlabel('Principal Component 1', fontsize=14)\n",
        "plt.ylabel('Principal Component 2', fontsize=14)\n",
        "ax = plt.gca()\n",
        "ax.set_axis_off()"
      ],
      "id": "16bca780",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can see that word2vec places the words representing countries close to each other and so do the words representing their capitals. The country-capital relationship is also roughly preserved, e.g., *Germany*-*Berlin* vector is roughly parallel to *France*-*Paris* vector.\n",
        "\n",
        "```{footbibliography}\n",
        "\n",
        "```"
      ],
      "id": "06743c60"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "netdatasci",
      "language": "python",
      "display_name": "netdatasci",
      "path": "/Users/skojaku-admin/Library/Jupyter/kernels/netdatasci"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}