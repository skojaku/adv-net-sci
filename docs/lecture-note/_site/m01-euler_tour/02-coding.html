<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Sadamori Kojaku">
<meta name="dcterms.date" content="2025-08-14">

<title>Coding Networks in Python – Advanced Topics in Network Science</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../m01-euler_tour/03-exercises.html" rel="next">
<link href="../m01-euler_tour/01-concepts.html" rel="prev">
<script src="../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting-0348920b7671f696dc9078d39bff215e.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap-e6dc204ec8b52f55243daf2cac742210.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "|"
  ],
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../assets/custom.css">
</head>

<body class="nav-sidebar docked nav-fixed slimcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../logo.jpg" alt="" class="navbar-logo">
    </a>
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Advanced Topics in Network Science</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-course" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Course</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-course">    
        <li>
    <a class="dropdown-item" href="../course/welcome.html">
 <span class="dropdown-text">Welcome</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../course/about.html">
 <span class="dropdown-text">About</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../course/discord.html">
 <span class="dropdown-text">Discord</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../course/minidora-usage.html">
 <span class="dropdown-text">Minidora</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../course/setup.html">
 <span class="dropdown-text">Setup</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-intro" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Intro</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-intro">    
        <li>
    <a class="dropdown-item" href="../intro/why-networks.html">
 <span class="dropdown-text">Why Networks?</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-foundations" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Foundations</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-foundations">    
        <li class="dropdown-header">─── M01: Euler Path ───</li>
        <li>
    <a class="dropdown-item" href="../m01-euler_tour/00-preparation.qmd">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m01-euler_tour/01-concepts.html">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m01-euler_tour/02-coding.html">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m01-euler_tour/03-exercises.html">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m01-euler_tour/04-advanced.html">
 <span class="dropdown-text">Advanced</span></a>
  </li>  
        <li class="dropdown-header">─── M02: Small World ───</li>
        <li>
    <a class="dropdown-item" href="../m02-small-world/00-preparation.qmd">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m02-small-world/01-concepts.html">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m02-small-world/02-coding.html">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m02-small-world/03-exercises.html">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m02-small-world/04-appendix.html">
 <span class="dropdown-text">Appendix</span></a>
  </li>  
        <li class="dropdown-header">─── M03: Robustness ───</li>
        <li>
    <a class="dropdown-item" href="../m03-robustness/00-preparation.md">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m03-robustness/01-concepts.html">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m03-robustness/02-coding.html">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m03-robustness/03-exercises.html">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m03-robustness/04-appendix.html">
 <span class="dropdown-text">Appendix</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-core-topics" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Core Topics</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-core-topics">    
        <li class="dropdown-header">─── M04: Friendship Paradox ───</li>
        <li>
    <a class="dropdown-item" href="../m04-friendship-paradox/00-preparation.md">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m04-friendship-paradox/01-concepts.md">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m04-friendship-paradox/02-coding.qmd">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m04-friendship-paradox/03-exercises.md">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
        <li class="dropdown-header">─── M05: Clustering ───</li>
        <li>
    <a class="dropdown-item" href="../m05-clustering/00-preparation.html">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m05-clustering/01-concepts.html">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m05-clustering/02-coding.html">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m05-clustering/03-exercises.html">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
        <li class="dropdown-header">─── M06: Centrality ───</li>
        <li>
    <a class="dropdown-item" href="../m06-centrality/00-preparation.html">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m06-centrality/01-concepts.html">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m06-centrality/02-coding.html">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m06-centrality/03-exercises.html">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-advanced-topics" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Advanced Topics</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-advanced-topics">    
        <li class="dropdown-header">─── M07: Random Walks ───</li>
        <li>
    <a class="dropdown-item" href="../m07-random-walks/00-preparation.html">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m07-random-walks/01-concepts.html">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m07-random-walks/02-coding.html">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m07-random-walks/03-exercises.html">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
        <li class="dropdown-header">─── M08: Embedding ───</li>
        <li>
    <a class="dropdown-item" href="../m08-embedding/00-preparation.html">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m08-embedding/01-concepts.html">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m08-embedding/02-coding.html">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m08-embedding/03-exercises.html">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m08-embedding/04-appendix.html">
 <span class="dropdown-text">Appendix</span></a>
  </li>  
        <li class="dropdown-header">─── M09: Graph Neural Networks ───</li>
        <li>
    <a class="dropdown-item" href="../m09-graph-neural-networks/00-preparation.html">
 <span class="dropdown-text">Preparation</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m09-graph-neural-networks/01-concepts.html">
 <span class="dropdown-text">Concepts</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m09-graph-neural-networks/02-coding.html">
 <span class="dropdown-text">Coding</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m09-graph-neural-networks/03-exercises.html">
 <span class="dropdown-text">Exercises</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="../m09-graph-neural-networks/04-appendix.html">
 <span class="dropdown-text">Appendix</span></a>
  </li>  
    </ul>
  </li>
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../m01-euler_tour/01-concepts.html">M01: Euler Path</a></li><li class="breadcrumb-item"><a href="../m01-euler_tour/02-coding.html">Coding Networks in Python</a></li></ol></nav>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation docked overflow-auto">
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false">
 <span class="menu-text">Course Information</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../course/welcome.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../course/about.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">About us</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../course/discord.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Discord</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../course/minidora-usage.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Using Minidora</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../course/setup.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Setup</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false">
 <span class="menu-text">Introduction</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../intro/why-networks.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Networks</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true">
 <span class="menu-text">M01: Euler Path</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m01-euler_tour/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">A Stroll, Seven Bridges, and a Mathematical Revolution</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m01-euler_tour/02-coding.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text">Coding Networks in Python</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m01-euler_tour/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exercises</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m01-euler_tour/04-advanced.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced: Sparse Matrices for Large-Scale Networks</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false">
 <span class="menu-text">M02: Small World</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-4" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-4" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m02-small-world/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Core Concepts</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m02-small-world/02-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Efficient Network Representation and Computing Paths</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m02-small-world/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exercises and Assignments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m02-small-world/04-appendix.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Appendix - Brief Introduction to igraph</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false">
 <span class="menu-text">M03: Robustness</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-5" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-5" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m03-robustness/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Core Concepts</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m03-robustness/02-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Coding - Network Robustness Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m03-robustness/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exercises and Assignments</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m03-robustness/04-appendix.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exercises and Assignments</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false">
 <span class="menu-text">M04: Friendship Paradox</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-6" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-6" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m04-node-degree/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Node Degree: The Building Block of Network Analysis</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m04-node-degree/02-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Visualizing Degree Distributions in Python</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m04-node-degree/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Exercises</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false">
 <span class="menu-text">M05: Clustering</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-7" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-7" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m05-clustering/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m05-clustering/02-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m05-clustering/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="false">
 <span class="menu-text">M06: Centrality</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-8" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-8" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m06-centrality/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m06-centrality/02-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m06-centrality/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="false">
 <span class="menu-text">M07: Random Walks</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-9" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-9" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m07-random-walks/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m07-random-walks/02-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m07-random-walks/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false">
 <span class="menu-text">M08: Embedding</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-10" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-10" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m08-embedding/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m08-embedding/02-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m08-embedding/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m08-embedding/04-appendix.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="false">
 <span class="menu-text">M09: Graph Neural Networks</span></a>
          <a class="sidebar-item-toggle text-start collapsed" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-11" role="navigation" aria-expanded="false" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-11" class="collapse list-unstyled sidebar-section depth1 ">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m09-graph-neural-networks/01-concepts.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m09-graph-neural-networks/02-coding.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m09-graph-neural-networks/03-exercises.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="../m09-graph-neural-networks/04-appendix.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Advanced Topics in Network Science</span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
    </div>
<!-- main -->
<main class="content page-columns page-full" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default"><nav class="quarto-page-breadcrumbs quarto-title-breadcrumbs d-none d-lg-block" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="../m01-euler_tour/01-concepts.html">M01: Euler Path</a></li><li class="breadcrumb-item"><a href="../m01-euler_tour/02-coding.html">Coding Networks in Python</a></li></ol></nav>
<div class="quarto-title">
<div class="quarto-title-block"><div><h1 class="title">Coding Networks in Python</h1><button type="button" class="btn code-tools-button" id="quarto-code-tools-source"><i class="bi"></i> Code</button></div></div>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Sadamori Kojaku </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">August 14, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<p>Now that you understand the conceptual foundation from Euler’s work, let’s explore how to represent and analyze networks computationally. Given a network of any size, our goal is to create a function that can tell us whether the network has an Euler path or not.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> has_euler_path(A):</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if a graph has an Euler path based on node degrees.</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co">    Complete this function based on Euler's theorem.</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="co">    A: network (assumed to be an adjacency matrix)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="co">    return: True if the network has an Euler path, False otherwise</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate degrees of all nodes</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>    degrees <span class="op">=</span> A.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count nodes with odd degrees</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    odd_degree_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> degree <span class="kw">in</span> degrees:</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> degree <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>            odd_degree_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># According to Euler's theorem, an Euler path exists if:</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. The graph is connected (we assume this for now)</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Exactly 0 or 2 nodes have odd degrees</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> odd_degree_count <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> odd_degree_count <span class="op">==</span> <span class="dv">2</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>We’ll work through both general network representations and apply them specifically to the Königsberg bridge problem.</p>
<section id="network-representations-from-pictures-to-data-structures" class="level2 page-columns page-full" data-number="1">
<h2 data-number="1" class="anchored" data-anchor-id="network-representations-from-pictures-to-data-structures"><span class="header-section-number">1</span> Network Representations: From Pictures to Data Structures</h2>
<p>Consider this network with 5 nodes and 6 edges:</p>
<div id="fig-small-graph" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<div aria-describedby="fig-small-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="https://www.tandfonline.com/cms/asset/2820b951-1747-4621-802c-8d04263f106c/tcon_a_1707286_f0001_oc.jpg" class="img-fluid figure-img" width="200">
</div>
<figcaption class="quarto-float-caption-bottom quarto-float-caption quarto-float-fig" id="fig-small-graph-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: A small graph of five nodes and six edges.
</figcaption>
</figure>
</div>
<p>How do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg’s bridges, we need data structures that capture the network’s essential connectivity while enabling efficient analysis.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>The choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.</p>
</div></div><p>Let’s explore three fundamental approaches that form the backbone of all network algorithms.</p>
<section id="edge-table-the-direct-approach" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="edge-table-the-direct-approach">Edge Table: The Direct Approach</h3>
<p>The edge table directly lists connections as pairs—the most intuitive way to store network data.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Edge tables are also called “edge lists” and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.</p>
</div></div><div id="a904f4c2" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Each row represents one edge (connection between two nodes)</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">1</span>),  <span class="co"># Node 0 connects to Node 1</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">2</span>),  <span class="co"># Node 0 connects to Node 2</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">2</span>),  <span class="co"># Node 1 connects to Node 2</span></span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">3</span>),  <span class="co"># Node 1 connects to Node 3</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>, <span class="dv">4</span>),  <span class="co"># Node 2 connects to Node 4</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">4</span>)   <span class="co"># Node 3 connects to Node 4</span></span>
<span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Network has </span><span class="sc">{</span><span class="bu">len</span>(edges)<span class="sc">}</span><span class="ss"> edges"</span>)</span>
<span id="cb2-12"><a href="#cb2-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Edge list:"</span>, edges)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Network has 6 edges
Edge list: [(0, 1), (0, 2), (1, 2), (1, 3), (2, 4), (3, 4)]</code></pre>
</div>
</div>
<p>This mirrors how we’d naturally describe the network: “Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3…” It’s the digital equivalent of Euler’s original approach—simply listing which bridges connect which landmasses.</p>
</section>
<section id="adjacency-list-the-neighborhood-map" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="adjacency-list-the-neighborhood-map">Adjacency List: The Neighborhood Map</h3>
<p>The adjacency list stores each node’s neighbors in a dictionary—like a social network where each person has a list of friends.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Most graph algorithms prefer adjacency lists because they allow fast iteration over a node’s neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.</p>
</div></div><div id="e7305e85" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define adjacency list directly as a dictionary</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>neighbors <span class="op">=</span> {</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],     <span class="co"># Node 0 connects to nodes 1 and 2</span></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>],  <span class="co"># Node 1 connects to nodes 0, 2, and 3</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>],  <span class="co"># Node 2 connects to nodes 0, 1, and 4</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [<span class="dv">1</span>, <span class="dv">4</span>],     <span class="co"># Node 3 connects to nodes 1 and 4</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: [<span class="dv">2</span>, <span class="dv">3</span>]      <span class="co"># Node 4 connects to nodes 2 and 3</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Adjacency list representation:"</span>)</span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node, neighbor_list <span class="kw">in</span> neighbors.items():</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Node </span><span class="sc">{</span>node<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>neighbor_list<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Adjacency list representation:
Node 0: [1, 2]
Node 1: [0, 2, 3]
Node 2: [0, 1, 4]
Node 3: [1, 4]
Node 4: [2, 3]</code></pre>
</div>
</div>
</section>
<section id="adjacency-matrix" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="adjacency-matrix">Adjacency Matrix</h3>
<p>The adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician’s favorite representation.</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>Adjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google’s PageRank algorithm fundamentally relies on matrix operations.</p>
</div></div><div id="11fe4509" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define adjacency matrix directly</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>matrix <span class="op">=</span> np.array([</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],  <span class="co"># Node 0 connects to nodes 1, 2</span></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>],  <span class="co"># Node 1 connects to nodes 0, 2, 3</span></span>
<span id="cb6-7"><a href="#cb6-7" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],  <span class="co"># Node 2 connects to nodes 0, 1, 4</span></span>
<span id="cb6-8"><a href="#cb6-8" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],  <span class="co"># Node 3 connects to nodes 1, 4</span></span>
<span id="cb6-9"><a href="#cb6-9" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>]   <span class="co"># Node 4 connects to nodes 2, 3</span></span>
<span id="cb6-10"><a href="#cb6-10" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb6-11"><a href="#cb6-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-12"><a href="#cb6-12" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Adjacency matrix:"</span>)</span>
<span id="cb6-13"><a href="#cb6-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(matrix)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Adjacency matrix:
[[0 1 1 0 0]
 [1 0 1 1 0]
 [1 1 0 0 1]
 [0 1 0 0 1]
 [0 0 1 1 0]]</code></pre>
</div>
</div>
<p>Notice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way.</p>
</section>
</section>
<section id="node-degrees" class="level2 page-columns page-full" data-number="2">
<h2 data-number="2" class="anchored" data-anchor-id="node-degrees"><span class="header-section-number">2</span> Node Degrees</h2>
<p>The degree of a node is the number of edges connected to it. This simple concept was central to Euler’s proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>In Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.</p>
</div></div><p>Here’s how to compute degrees using each representation:</p>
<section id="from-edge-table" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="from-edge-table">From Edge Table</h3>
<p>Count how many times each node appears in the edge list.</p>
<div id="b9a7b1b4" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>_degrees <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node1, node2 <span class="kw">in</span> edges:</span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    _degrees[node1] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    _degrees[node2] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Degrees from edge list:"</span>, _degrees)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Degrees from edge list: [2, 3, 3, 2, 2]</code></pre>
</div>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p>We increment the degree counter for both nodes in each edge because every edge contributes to two nodes’ degrees. This is why the total degree always equals twice the number of edges.</p>
</div></div></section>
<section id="from-adjacency-list" class="level3">
<h3 class="anchored" data-anchor-id="from-adjacency-list">From Adjacency List</h3>
<p>Count the length of each node’s neighbor list—the most direct approach.</p>
<div id="d0bc21d9" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>_degrees <span class="op">=</span> [<span class="bu">len</span>(neighbors[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Degrees from adjacency list:"</span>, _degrees)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Degrees from adjacency list: [2, 3, 3, 2, 2]</code></pre>
</div>
</div>
</section>
<section id="from-adjacency-matrix" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="from-adjacency-matrix">From Adjacency Matrix</h3>
<p>Sum each row (or column) of the matrix—leveraging vectorized operations.</p>
<div id="f93797a8" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>_degrees <span class="op">=</span> matrix.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)  <span class="co"># Sum rows</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Degrees from adjacency matrix:"</span>, _degrees)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Degrees from adjacency matrix: [2 3 3 2 2]</code></pre>
</div>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p>For undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections).</p>
</div></div></section>
</section>
<section id="checking-for-trails-walks-and-paths" class="level2 page-columns page-full" data-number="3">
<h2 data-number="3" class="anchored" data-anchor-id="checking-for-trails-walks-and-paths"><span class="header-section-number">3</span> Checking for Trails, Walks, and Paths</h2>
<p>Now that we understand how to represent networks and compute degrees, let’s implement functions to verify whether a sequence of nodes represents a valid walk, trail, path, or cycle. These verification algorithms are essential for network analysis and implementing graph traversal algorithms.</p>
<section id="verifying-a-walk" class="level3">
<h3 class="anchored" data-anchor-id="verifying-a-walk">Verifying a Walk</h3>
<p>A <strong>walk</strong> is the most permissive—we simply need to check that each consecutive pair of nodes is connected by an edge.</p>
<div id="e50884ea" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb14"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_walk(sequence, adjacency_matrix):</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if a sequence of nodes forms a valid walk.</span></span>
<span id="cb14-4"><a href="#cb14-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-5"><a href="#cb14-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb14-6"><a href="#cb14-6" aria-hidden="true" tabindex="-1"></a><span class="co">        sequence: List of node indices [v0, v1, v2, ...]</span></span>
<span id="cb14-7"><a href="#cb14-7" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array representing the graph</span></span>
<span id="cb14-8"><a href="#cb14-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-9"><a href="#cb14-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb14-10"><a href="#cb14-10" aria-hidden="true" tabindex="-1"></a><span class="co">        bool: True if sequence is a valid walk, False otherwise</span></span>
<span id="cb14-11"><a href="#cb14-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb14-12"><a href="#cb14-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sequence) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb14-13"><a href="#cb14-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span>  <span class="co"># Single node or empty sequence is trivially a walk</span></span>
<span id="cb14-14"><a href="#cb14-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-15"><a href="#cb14-15" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use NumPy vectorized operations for efficient edge checking</span></span>
<span id="cb14-16"><a href="#cb14-16" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> np.array(sequence)</span>
<span id="cb14-17"><a href="#cb14-17" aria-hidden="true" tabindex="-1"></a>    current_nodes <span class="op">=</span> sequence[:<span class="op">-</span><span class="dv">1</span>]  <span class="co"># All nodes except the last</span></span>
<span id="cb14-18"><a href="#cb14-18" aria-hidden="true" tabindex="-1"></a>    next_nodes <span class="op">=</span> sequence[<span class="dv">1</span>:]      <span class="co"># All nodes except the first</span></span>
<span id="cb14-19"><a href="#cb14-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-20"><a href="#cb14-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simple but slower: for loop version (slower but more explicit)</span></span>
<span id="cb14-21"><a href="#cb14-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for i, j in zip(current_nodes, next_nodes):</span></span>
<span id="cb14-22"><a href="#cb14-22" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     if adjacency_matrix[i, j] == 0:</span></span>
<span id="cb14-23"><a href="#cb14-23" aria-hidden="true" tabindex="-1"></a>    <span class="co">#         return False</span></span>
<span id="cb14-24"><a href="#cb14-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># return True</span></span>
<span id="cb14-25"><a href="#cb14-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-26"><a href="#cb14-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check all edges at once using advanced indexing</span></span>
<span id="cb14-27"><a href="#cb14-27" aria-hidden="true" tabindex="-1"></a>    edges_exist <span class="op">=</span> adjacency_matrix[current_nodes, next_nodes]</span>
<span id="cb14-28"><a href="#cb14-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-29"><a href="#cb14-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># All edges must exist (all values must be 1)</span></span>
<span id="cb14-30"><a href="#cb14-30" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">all</span>(edges_exist <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb14-31"><a href="#cb14-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-32"><a href="#cb14-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-33"><a href="#cb14-33" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with our sample network</span></span>
<span id="cb14-34"><a href="#cb14-34" aria-hidden="true" tabindex="-1"></a>test_sequence <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>]</span>
<span id="cb14-35"><a href="#cb14-35" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>test_sequence<span class="sc">}</span><span class="ss"> is a valid walk: </span><span class="sc">{</span>is_walk(test_sequence, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb14-36"><a href="#cb14-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb14-37"><a href="#cb14-37" aria-hidden="true" tabindex="-1"></a><span class="co"># Test an invalid walk</span></span>
<span id="cb14-38"><a href="#cb14-38" aria-hidden="true" tabindex="-1"></a>invalid_sequence <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">3</span>]  <span class="co"># No direct edge between 0 and 3</span></span>
<span id="cb14-39"><a href="#cb14-39" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>invalid_sequence<span class="sc">}</span><span class="ss"> is a valid walk: </span><span class="sc">{</span>is_walk(invalid_sequence, matrix)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sequence [0, 1, 2, 4, 3, 1] is a valid walk: True
Sequence [0, 3] is a valid walk: False</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled" title="Mind the loops!">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Mind the loops!
</div>
</div>
<div class="callout-body-container callout-body">
<p>For loops in Python is the notorious source of computational bottlenecks. Avoiding for loops significantly boosts the speed. In <code>is_walk</code>, we use one for loop but you can avoid it by using NumPy’s advanced indexing, i.e., <code>adjacency_matrix[(current_nodes, next_nodes)]</code>. The way to think about this is that <code>(current_nodes, next_nodes)</code> is a tuple of indices, acting as a multi-dimensional index. <code>adjacency_matrix[(current_nodes, next_nodes)]</code> is 1d array of length the same as <code>current_nodes</code> and <code>next_nodes</code>. If the value is 0, then the edge does not exist. We can then check if all the values are not zero.</p>
</div>
</div>
</section>
<section id="verifying-a-trail" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="verifying-a-trail">Verifying a Trail</h3>
<p>A <strong>trail</strong> requires all edges to be distinct, but nodes can repeat.</p>
<div id="d10842d2" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_trail(sequence, adjacency_matrix):</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if a sequence of nodes forms a valid trail.</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a><span class="co">        sequence: List of node indices [v0, v1, v2, ...]</span></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array representing the graph</span></span>
<span id="cb16-8"><a href="#cb16-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-9"><a href="#cb16-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb16-10"><a href="#cb16-10" aria-hidden="true" tabindex="-1"></a><span class="co">        bool: True if sequence is a valid trail, False otherwise</span></span>
<span id="cb16-11"><a href="#cb16-11" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb16-12"><a href="#cb16-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> is_walk(sequence, adjacency_matrix):</span>
<span id="cb16-13"><a href="#cb16-13" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Must be a valid walk first</span></span>
<span id="cb16-14"><a href="#cb16-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-15"><a href="#cb16-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sequence) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb16-16"><a href="#cb16-16" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb16-17"><a href="#cb16-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-18"><a href="#cb16-18" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to numpy for efficient operations</span></span>
<span id="cb16-19"><a href="#cb16-19" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> np.array(sequence)</span>
<span id="cb16-20"><a href="#cb16-20" aria-hidden="true" tabindex="-1"></a>    current_nodes <span class="op">=</span> sequence[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb16-21"><a href="#cb16-21" aria-hidden="true" tabindex="-1"></a>    next_nodes <span class="op">=</span> sequence[<span class="dv">1</span>:]</span>
<span id="cb16-22"><a href="#cb16-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-23"><a href="#cb16-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use complex numbers to represent edges!</span></span>
<span id="cb16-24"><a href="#cb16-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For undirected graph: smaller_node + 1j * larger_node</span></span>
<span id="cb16-25"><a href="#cb16-25" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This ensures edge (1,2) and (2,1) both become 1+2j</span></span>
<span id="cb16-26"><a href="#cb16-26" aria-hidden="true" tabindex="-1"></a>    edge_starts <span class="op">=</span> np.minimum(current_nodes, next_nodes)  <span class="co"># Real part</span></span>
<span id="cb16-27"><a href="#cb16-27" aria-hidden="true" tabindex="-1"></a>    edge_ends <span class="op">=</span> np.maximum(current_nodes, next_nodes)    <span class="co"># Imaginary part</span></span>
<span id="cb16-28"><a href="#cb16-28" aria-hidden="true" tabindex="-1"></a>    complex_edges <span class="op">=</span> edge_starts <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> edge_ends</span>
<span id="cb16-29"><a href="#cb16-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-30"><a href="#cb16-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check uniqueness directly with NumPy</span></span>
<span id="cb16-31"><a href="#cb16-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(complex_edges) <span class="op">==</span> <span class="bu">len</span>(np.unique(complex_edges))</span>
<span id="cb16-32"><a href="#cb16-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-33"><a href="#cb16-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Alternative: Original for loop version (slower but more explicit)</span></span>
<span id="cb16-34"><a href="#cb16-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># used_edges = set()</span></span>
<span id="cb16-35"><a href="#cb16-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for i in range(len(sequence) - 1):</span></span>
<span id="cb16-36"><a href="#cb16-36" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     current_node = sequence[i]</span></span>
<span id="cb16-37"><a href="#cb16-37" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     next_node = sequence[i + 1]</span></span>
<span id="cb16-38"><a href="#cb16-38" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     # Create edge tuple (smaller index first for undirected graphs)</span></span>
<span id="cb16-39"><a href="#cb16-39" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     edge = (min(current_node, next_node), max(current_node, next_node))</span></span>
<span id="cb16-40"><a href="#cb16-40" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     if edge in used_edges:</span></span>
<span id="cb16-41"><a href="#cb16-41" aria-hidden="true" tabindex="-1"></a>    <span class="co">#         return False  # Edge already used</span></span>
<span id="cb16-42"><a href="#cb16-42" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     used_edges.add(edge)</span></span>
<span id="cb16-43"><a href="#cb16-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># return True</span></span>
<span id="cb16-44"><a href="#cb16-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-45"><a href="#cb16-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Test trail verification</span></span>
<span id="cb16-46"><a href="#cb16-46" aria-hidden="true" tabindex="-1"></a>trail_sequence <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>]</span>
<span id="cb16-47"><a href="#cb16-47" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>trail_sequence<span class="sc">}</span><span class="ss"> is a valid trail: </span><span class="sc">{</span>is_trail(trail_sequence, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb16-48"><a href="#cb16-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-49"><a href="#cb16-49" aria-hidden="true" tabindex="-1"></a><span class="co"># Test invalid trail (reuses edge 1-2)</span></span>
<span id="cb16-50"><a href="#cb16-50" aria-hidden="true" tabindex="-1"></a>invalid_trail <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]</span>
<span id="cb16-51"><a href="#cb16-51" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>invalid_trail<span class="sc">}</span><span class="ss"> is a valid trail: </span><span class="sc">{</span>is_trail(invalid_trail, matrix)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sequence [0, 1, 3, 4, 2] is a valid trail: True
Sequence [0, 1, 2, 1, 3] is a valid trail: False</code></pre>
</div>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p><code>np.unique</code> is a powerful function that can handle complex numbers natively.</p>
</div></div><div class="callout callout-style-default callout-note callout-titled" title="Complex Numbers for Edge Representation">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Complex Numbers for Edge Representation
</div>
</div>
<div class="callout-body-container callout-body">
<p>We use complex numbers to represent edges! Each edge becomes <code>smaller_node + 1j * larger_node</code>. For example, edge (1,2) becomes <code>1+2j</code>, and edge (2,1) also becomes <code>1+2j</code> (normalized). Think of complex numbers as natural 2D coordinates for representing node pairs.</p>
</div>
</div>
</section>
<section id="verifying-a-path" class="level3">
<h3 class="anchored" data-anchor-id="verifying-a-path">Verifying a Path</h3>
<p>A <strong>path</strong> requires all nodes (except possibly start/end for cycles) to be distinct.</p>
<div id="527574be" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_path(sequence, adjacency_matrix):</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if a sequence of nodes forms a valid path.</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-5"><a href="#cb18-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb18-6"><a href="#cb18-6" aria-hidden="true" tabindex="-1"></a><span class="co">        sequence: List of node indices [v0, v1, v2, ...]</span></span>
<span id="cb18-7"><a href="#cb18-7" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array representing the graph</span></span>
<span id="cb18-8"><a href="#cb18-8" aria-hidden="true" tabindex="-1"></a><span class="co">        allow_cycle: If True, allows start node = end node (cycle)</span></span>
<span id="cb18-9"><a href="#cb18-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-10"><a href="#cb18-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb18-11"><a href="#cb18-11" aria-hidden="true" tabindex="-1"></a><span class="co">        bool: True if sequence is a valid path, False otherwise</span></span>
<span id="cb18-12"><a href="#cb18-12" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb18-13"><a href="#cb18-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> is_walk(sequence, adjacency_matrix):</span>
<span id="cb18-14"><a href="#cb18-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Must be a valid walk first</span></span>
<span id="cb18-15"><a href="#cb18-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-16"><a href="#cb18-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sequence) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb18-17"><a href="#cb18-17" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb18-18"><a href="#cb18-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-19"><a href="#cb18-19" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> np.array(sequence)</span>
<span id="cb18-20"><a href="#cb18-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-21"><a href="#cb18-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(sequence) <span class="op">==</span> <span class="bu">len</span>(np.unique(sequence))</span>
<span id="cb18-22"><a href="#cb18-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-23"><a href="#cb18-23" aria-hidden="true" tabindex="-1"></a><span class="co"># Test path verification</span></span>
<span id="cb18-24"><a href="#cb18-24" aria-hidden="true" tabindex="-1"></a>path_sequence <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb18-25"><a href="#cb18-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>path_sequence<span class="sc">}</span><span class="ss"> is a valid path: </span><span class="sc">{</span>is_path(path_sequence, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb18-26"><a href="#cb18-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-27"><a href="#cb18-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Test invalid path (repeats node 1)</span></span>
<span id="cb18-28"><a href="#cb18-28" aria-hidden="true" tabindex="-1"></a>invalid_path <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]</span>
<span id="cb18-29"><a href="#cb18-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>invalid_path<span class="sc">}</span><span class="ss"> is a valid path: </span><span class="sc">{</span>is_path(invalid_path, matrix)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Sequence [0, 1, 3, 4] is a valid path: True
Sequence [0, 1, 2, 1, 3] is a valid path: False</code></pre>
</div>
</div>
</section>
</section>
<section id="connected-components" class="level2 page-columns page-full" data-number="4">
<h2 data-number="4" class="anchored" data-anchor-id="connected-components"><span class="header-section-number">4</span> Connected Components</h2>
<p>Connected components are the maximal sets of nodes where every pair is connected by some path. For Euler path analysis, this is crucial—an Euler path can only exist if the entire graph forms a single connected component (or if we’re only considering the component containing edges).</p>

<div class="no-row-height column-margin column-container"><div class="">
<p>In Königsberg, all landmasses were connected by bridges, forming one component. If one landmass were isolated, no Euler path could traverse the entire city. This connectivity requirement is the first condition in Euler’s theorem.</p>
</div></div><section id="the-algorithm-depth-first-search" class="level3 page-columns page-full">
<h3 class="anchored" data-anchor-id="the-algorithm-depth-first-search">The Algorithm: Depth-First Search</h3>
<p>A simple way to find connected components is to systematically explore from each unvisited node using depth-first search (DFS). This works because DFS can only reach nodes that are connected through some path.</p>
<p><strong>Algorithm steps:</strong> 1. Mark all nodes as unvisited 2. For each unvisited node: - Start a new component - Use DFS to explore all reachable nodes - Add all reached nodes to this component 3. Return the list of components</p>
<div id="0ab309a5" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> connected_components(adjacency_matrix):</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Find connected components in an undirected graph using adjacency matrix.</span></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array (square)</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co">        List of lists, each sublist contains node indices in a component</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb20-11"><a href="#cb20-11" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb20-12"><a href="#cb20-12" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> adjacency_matrix.shape[<span class="dv">0</span>]</span>
<span id="cb20-13"><a href="#cb20-13" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> np.zeros(n, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb20-14"><a href="#cb20-14" aria-hidden="true" tabindex="-1"></a>    components <span class="op">=</span> []</span>
<span id="cb20-15"><a href="#cb20-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-16"><a href="#cb20-16" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(node, component):</span>
<span id="cb20-17"><a href="#cb20-17" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Depth-first search to explore a component"""</span></span>
<span id="cb20-18"><a href="#cb20-18" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Mark the current node as visited and add it to current component</span></span>
<span id="cb20-19"><a href="#cb20-19" aria-hidden="true" tabindex="-1"></a>        visited[node] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb20-20"><a href="#cb20-20" aria-hidden="true" tabindex="-1"></a>        component.append(node)</span>
<span id="cb20-21"><a href="#cb20-21" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-22"><a href="#cb20-22" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find all neighbors of the current node using vectorized operation</span></span>
<span id="cb20-23"><a href="#cb20-23" aria-hidden="true" tabindex="-1"></a>        neighbors <span class="op">=</span> np.where(adjacency_matrix[node] <span class="op">&gt;</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb20-24"><a href="#cb20-24" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb20-25"><a href="#cb20-25" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Recursively visit unvisited neighbors</span></span>
<span id="cb20-26"><a href="#cb20-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor <span class="kw">in</span> neighbors:</span>
<span id="cb20-27"><a href="#cb20-27" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> visited[neighbor]:</span>
<span id="cb20-28"><a href="#cb20-28" aria-hidden="true" tabindex="-1"></a>                dfs(neighbor, component)</span>
<span id="cb20-29"><a href="#cb20-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-30"><a href="#cb20-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Main algorithm: iterate through all nodes</span></span>
<span id="cb20-31"><a href="#cb20-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb20-32"><a href="#cb20-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> visited[v]:  <span class="co"># Found a new component</span></span>
<span id="cb20-33"><a href="#cb20-33" aria-hidden="true" tabindex="-1"></a>            component <span class="op">=</span> []</span>
<span id="cb20-34"><a href="#cb20-34" aria-hidden="true" tabindex="-1"></a>            dfs(v, component)  <span class="co"># Explore entire component</span></span>
<span id="cb20-35"><a href="#cb20-35" aria-hidden="true" tabindex="-1"></a>            components.append(component)</span>
<span id="cb20-36"><a href="#cb20-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb20-37"><a href="#cb20-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> components</span>
<span id="cb20-38"><a href="#cb20-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-39"><a href="#cb20-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with our original connected graph</span></span>
<span id="cb20-40"><a href="#cb20-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Testing with connected graph:"</span>)</span>
<span id="cb20-41"><a href="#cb20-41" aria-hidden="true" tabindex="-1"></a>components <span class="op">=</span> connected_components(matrix)</span>
<span id="cb20-42"><a href="#cb20-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Connected components:"</span>, components)</span>
<span id="cb20-43"><a href="#cb20-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of components: </span><span class="sc">{</span><span class="bu">len</span>(components)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb20-44"><a href="#cb20-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-45"><a href="#cb20-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a disconnected graph to demonstrate multiple components</span></span>
<span id="cb20-46"><a href="#cb20-46" aria-hidden="true" tabindex="-1"></a>disconnected_matrix <span class="op">=</span> np.array([</span>
<span id="cb20-47"><a href="#cb20-47" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],  <span class="co"># Component 1: nodes 0,1,2</span></span>
<span id="cb20-48"><a href="#cb20-48" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],  </span>
<span id="cb20-49"><a href="#cb20-49" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],  </span>
<span id="cb20-50"><a href="#cb20-50" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],  <span class="co"># Component 2: nodes 3,4</span></span>
<span id="cb20-51"><a href="#cb20-51" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]   </span>
<span id="cb20-52"><a href="#cb20-52" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb20-53"><a href="#cb20-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-54"><a href="#cb20-54" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Testing with disconnected graph:"</span>)</span>
<span id="cb20-55"><a href="#cb20-55" aria-hidden="true" tabindex="-1"></a>disconnected_components <span class="op">=</span> connected_components(disconnected_matrix)</span>
<span id="cb20-56"><a href="#cb20-56" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Connected components:"</span>, disconnected_components)</span>
<span id="cb20-57"><a href="#cb20-57" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of components: </span><span class="sc">{</span><span class="bu">len</span>(disconnected_components)<span class="sc">}</span><span class="ss">"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Testing with connected graph:
Connected components: [[0, np.int64(1), np.int64(2), np.int64(4), np.int64(3)]]
Number of components: 1

Testing with disconnected graph:
Connected components: [[0, np.int64(1), np.int64(2)], [3, np.int64(4)]]
Number of components: 2</code></pre>
</div>
</div>

<div class="no-row-height column-margin column-container"><div class="">
<p>DFS naturally explores as “deep” as possible before backtracking. This makes it perfect for component finding because once we start exploring from a node, we want to find ALL nodes in its component before moving to the next component.</p>
</div></div></section>
<section id="improved-euler-path-checker" class="level3">
<h3 class="anchored" data-anchor-id="improved-euler-path-checker">Improved Euler Path Checker</h3>
<p>Now we can enhance our Euler path function to include the connectivity requirement:</p>
<div id="9660697a" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> has_euler_path_complete(adjacency_matrix):</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Complete Euler path checker with connectivity verification.</span></span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array representing the graph</span></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a><span class="co">        bool: True if graph has an Euler path, False otherwise</span></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if graph is connected (ignoring isolated nodes)</span></span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>    components <span class="op">=</span> connected_components(adjacency_matrix)</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find nodes with at least one edge (degree &gt; 0)</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>    degrees <span class="op">=</span> adjacency_matrix.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    non_isolated_nodes <span class="op">=</span> np.where(degrees <span class="op">&gt;</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(non_isolated_nodes) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span>  <span class="co"># Empty graph has Euler path trivially</span></span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if all non-isolated nodes are in the same component</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a>    component_with_edges <span class="op">=</span> <span class="va">None</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> component <span class="kw">in</span> components:</span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> non_isolated_nodes[<span class="dv">0</span>] <span class="kw">in</span> component:</span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>            component_with_edges <span class="op">=</span> <span class="bu">set</span>(component)</span>
<span id="cb22-26"><a href="#cb22-26" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb22-27"><a href="#cb22-27" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-28"><a href="#cb22-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># All nodes with edges must be in the same component</span></span>
<span id="cb22-29"><a href="#cb22-29" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>(node <span class="kw">in</span> component_with_edges <span class="cf">for</span> node <span class="kw">in</span> non_isolated_nodes):</span>
<span id="cb22-30"><a href="#cb22-30" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Graph is disconnected</span></span>
<span id="cb22-31"><a href="#cb22-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-32"><a href="#cb22-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count nodes with odd degrees (among non-isolated nodes)</span></span>
<span id="cb22-33"><a href="#cb22-33" aria-hidden="true" tabindex="-1"></a>    non_isolated_degrees <span class="op">=</span> degrees[non_isolated_nodes]</span>
<span id="cb22-34"><a href="#cb22-34" aria-hidden="true" tabindex="-1"></a>    odd_degree_count <span class="op">=</span> np.<span class="bu">sum</span>(non_isolated_degrees <span class="op">%</span> <span class="dv">2</span>)</span>
<span id="cb22-35"><a href="#cb22-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb22-36"><a href="#cb22-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Euler's theorem: exactly 0 or 2 nodes with odd degrees</span></span>
<span id="cb22-37"><a href="#cb22-37" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> odd_degree_count <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> odd_degree_count <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb22-38"><a href="#cb22-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-39"><a href="#cb22-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with connected graph</span></span>
<span id="cb22-40"><a href="#cb22-40" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Connected graph has Euler path:"</span>, has_euler_path_complete(matrix))</span>
<span id="cb22-41"><a href="#cb22-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-42"><a href="#cb22-42" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with disconnected graph</span></span>
<span id="cb22-43"><a href="#cb22-43" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Disconnected graph has Euler path:"</span>, has_euler_path_complete(disconnected_matrix))</span>
<span id="cb22-44"><a href="#cb22-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-45"><a href="#cb22-45" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the classic Königsberg bridge problem (all odd degrees)</span></span>
<span id="cb22-46"><a href="#cb22-46" aria-hidden="true" tabindex="-1"></a>konigsberg <span class="op">=</span> np.array([</span>
<span id="cb22-47"><a href="#cb22-47" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],  <span class="co"># Landmass 0 connects to all others (degree 3)</span></span>
<span id="cb22-48"><a href="#cb22-48" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>],  <span class="co"># Landmass 1 connects to all others (degree 3)</span></span>
<span id="cb22-49"><a href="#cb22-49" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>],  <span class="co"># Landmass 2 connects to all others (degree 3)</span></span>
<span id="cb22-50"><a href="#cb22-50" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>]   <span class="co"># Landmass 3 connects to all others (degree 3)</span></span>
<span id="cb22-51"><a href="#cb22-51" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb22-52"><a href="#cb22-52" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Königsberg bridges have Euler path:"</span>, has_euler_path_complete(konigsberg))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Connected graph has Euler path: True
Disconnected graph has Euler path: False
Königsberg bridges have Euler path: False</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-important callout-titled" title="Why Connectivity Matters">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Why Connectivity Matters
</div>
</div>
<div class="callout-body-container callout-body">
<p>Even if a graph has exactly 2 odd-degree nodes, an Euler path cannot exist if those nodes are in different connected components. You cannot traverse from one component to another without existing edges, making a single continuous path impossible.</p>
</div>
</div>
</section>
<section id="visualizing-component-structure" class="level3">
<h3 class="anchored" data-anchor-id="visualizing-component-structure">Visualizing Component Structure</h3>
<p>Understanding component structure helps debug complex networks:</p>
<div id="d562c5cf" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_graph_structure(adjacency_matrix):</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Comprehensive analysis of graph structure for Euler path feasibility."""</span></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> adjacency_matrix.shape[<span class="dv">0</span>]</span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>    degrees <span class="op">=</span> adjacency_matrix.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>    components <span class="op">=</span> connected_components(adjacency_matrix)</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Graph Analysis:"</span>)</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"- Total nodes: </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"- Total edges: </span><span class="sc">{</span>adjacency_matrix<span class="sc">.</span><span class="bu">sum</span>() <span class="op">//</span> <span class="dv">2</span><span class="sc">}</span><span class="ss">"</span>)  <span class="co"># Divide by 2 for undirected</span></span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"- Connected components: </span><span class="sc">{</span><span class="bu">len</span>(components)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Analyze each component</span></span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, component <span class="kw">in</span> <span class="bu">enumerate</span>(components):</span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>        component_degrees <span class="op">=</span> degrees[component]</span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>        odd_count <span class="op">=</span> np.<span class="bu">sum</span>(component_degrees <span class="op">%</span> <span class="dv">2</span>)</span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Component </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: nodes </span><span class="sc">{</span>component<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  - Size: </span><span class="sc">{</span><span class="bu">len</span>(component)<span class="sc">}</span><span class="ss"> nodes"</span>)</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  - Node degrees: </span><span class="sc">{</span><span class="bu">dict</span>(<span class="bu">zip</span>(component, component_degrees))<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  - Odd degree nodes: </span><span class="sc">{</span>odd_count<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  - Has Euler path: </span><span class="sc">{</span>odd_count <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> odd_count <span class="op">==</span> <span class="dv">2</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb24-23"><a href="#cb24-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Overall Euler path conclusion</span></span>
<span id="cb24-24"><a href="#cb24-24" aria-hidden="true" tabindex="-1"></a>    non_isolated <span class="op">=</span> np.where(degrees <span class="op">&gt;</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb24-25"><a href="#cb24-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(non_isolated) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb24-26"><a href="#cb24-26" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if all non-isolated nodes are in same component</span></span>
<span id="cb24-27"><a href="#cb24-27" aria-hidden="true" tabindex="-1"></a>        main_component <span class="op">=</span> <span class="va">None</span></span>
<span id="cb24-28"><a href="#cb24-28" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> comp <span class="kw">in</span> components:</span>
<span id="cb24-29"><a href="#cb24-29" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> non_isolated[<span class="dv">0</span>] <span class="kw">in</span> comp:</span>
<span id="cb24-30"><a href="#cb24-30" aria-hidden="true" tabindex="-1"></a>                main_component <span class="op">=</span> <span class="bu">set</span>(comp)</span>
<span id="cb24-31"><a href="#cb24-31" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb24-32"><a href="#cb24-32" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb24-33"><a href="#cb24-33" aria-hidden="true" tabindex="-1"></a>        connected <span class="op">=</span> <span class="bu">all</span>(node <span class="kw">in</span> main_component <span class="cf">for</span> node <span class="kw">in</span> non_isolated)</span>
<span id="cb24-34"><a href="#cb24-34" aria-hidden="true" tabindex="-1"></a>        odd_total <span class="op">=</span> np.<span class="bu">sum</span>(degrees[non_isolated] <span class="op">%</span> <span class="dv">2</span>)</span>
<span id="cb24-35"><a href="#cb24-35" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb24-36"><a href="#cb24-36" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Overall Euler Path Analysis:"</span>)</span>
<span id="cb24-37"><a href="#cb24-37" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"- All edges connected: </span><span class="sc">{</span>connected<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-38"><a href="#cb24-38" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"- Total odd degree nodes: </span><span class="sc">{</span>odd_total<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-39"><a href="#cb24-39" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"- Has Euler path: </span><span class="sc">{</span>connected <span class="kw">and</span> (odd_total <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> odd_total <span class="op">==</span> <span class="dv">2</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb24-40"><a href="#cb24-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-41"><a href="#cb24-41" aria-hidden="true" tabindex="-1"></a><span class="co"># Analyze our example graphs</span></span>
<span id="cb24-42"><a href="#cb24-42" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"=== Original Connected Graph ==="</span>)</span>
<span id="cb24-43"><a href="#cb24-43" aria-hidden="true" tabindex="-1"></a>analyze_graph_structure(matrix)</span>
<span id="cb24-44"><a href="#cb24-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-45"><a href="#cb24-45" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Disconnected Graph ==="</span>)</span>
<span id="cb24-46"><a href="#cb24-46" aria-hidden="true" tabindex="-1"></a>analyze_graph_structure(disconnected_matrix)</span>
<span id="cb24-47"><a href="#cb24-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-48"><a href="#cb24-48" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Königsberg Bridges ==="</span>)</span>
<span id="cb24-49"><a href="#cb24-49" aria-hidden="true" tabindex="-1"></a>analyze_graph_structure(konigsberg)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>=== Original Connected Graph ===
Graph Analysis:
- Total nodes: 5
- Total edges: 6
- Connected components: 1

Component 0: nodes [0, np.int64(1), np.int64(2), np.int64(4), np.int64(3)]
  - Size: 5 nodes
  - Node degrees: {0: np.int64(2), np.int64(1): np.int64(3), np.int64(2): np.int64(3), np.int64(4): np.int64(2), np.int64(3): np.int64(2)}
  - Odd degree nodes: 2
  - Has Euler path: True

Overall Euler Path Analysis:
- All edges connected: True
- Total odd degree nodes: 2
- Has Euler path: True

=== Disconnected Graph ===
Graph Analysis:
- Total nodes: 5
- Total edges: 3
- Connected components: 2

Component 0: nodes [0, np.int64(1), np.int64(2)]
  - Size: 3 nodes
  - Node degrees: {0: np.int64(1), np.int64(1): np.int64(2), np.int64(2): np.int64(1)}
  - Odd degree nodes: 2
  - Has Euler path: True

Component 1: nodes [3, np.int64(4)]
  - Size: 2 nodes
  - Node degrees: {3: np.int64(1), np.int64(4): np.int64(1)}
  - Odd degree nodes: 2
  - Has Euler path: True

Overall Euler Path Analysis:
- All edges connected: False
- Total odd degree nodes: 4
- Has Euler path: False

=== Königsberg Bridges ===
Graph Analysis:
- Total nodes: 4
- Total edges: 6
- Connected components: 1

Component 0: nodes [0, np.int64(1), np.int64(2), np.int64(3)]
  - Size: 4 nodes
  - Node degrees: {0: np.int64(3), np.int64(1): np.int64(3), np.int64(2): np.int64(3), np.int64(3): np.int64(3)}
  - Odd degree nodes: 4
  - Has Euler path: False

Overall Euler Path Analysis:
- All edges connected: True
- Total odd degree nodes: 4
- Has Euler path: False</code></pre>
</div>
</div>
</section>
</section>
<section id="summary" class="level2" data-number="5">
<h2 data-number="5" class="anchored" data-anchor-id="summary"><span class="header-section-number">5</span> Summary</h2>
<p>You now understand how to:</p>
<ol type="1">
<li><strong>Represent networks</strong> using edge lists, adjacency lists, and adjacency matrices—each optimized for different computational tasks</li>
<li><strong>Compute node degrees</strong> efficiently using vectorized operations across all representations</li>
<li><strong>Verify walks, trails, paths, and cycles</strong> with robust algorithms that handle edge cases</li>
<li><strong>Find connected components</strong> using depth-first search to identify disconnected parts of networks</li>
<li><strong>Apply Euler’s theorem completely</strong> by checking both degree conditions and connectivity requirements</li>
</ol>
<div class="callout callout-style-default callout-tip callout-titled" title="Computational Complexity">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Computational Complexity
</div>
</div>
<div class="callout-body-container callout-body">
<ul>
<li>Degree calculation: O(n²) for adjacency matrix, O(E) for edge list, O(1) for adjacency list</li>
<li>Walk verification: O(k) where k is sequence length</li>
<li>Connected components: O(n²) for adjacency matrix representation using DFS</li>
<li>Complete Euler path check: O(n²) dominated by connectivity check</li>
</ul>
</div>
</div>
<p>These fundamental algorithms form the building blocks for more sophisticated network analysis. Whether you’re analyzing social networks, transportation systems, or molecular structures, these core concepts of connectivity, traversal, and structural analysis remain essential.</p>
<p>From Euler’s original insight about Königsberg’s bridges to modern network science, the mathematical principles you’ve implemented here continue to solve real-world problems—from GPS routing algorithms to understanding brain connectivity patterns.</p>


<!-- -->

</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
    const viewSource = window.document.getElementById('quarto-view-source') ||
                       window.document.getElementById('quarto-code-tools-source');
    if (viewSource) {
      const sourceUrl = viewSource.getAttribute("data-quarto-source-url");
      viewSource.addEventListener("click", function(e) {
        if (sourceUrl) {
          // rstudio viewer pane
          if (/\bcapabilities=\b/.test(window.location)) {
            window.open(sourceUrl);
          } else {
            window.location.href = sourceUrl;
          }
        } else {
          const modal = new bootstrap.Modal(document.getElementById('quarto-embedded-source-code-modal'));
          modal.show();
        }
        return false;
      });
    }
    function toggleCodeHandler(show) {
      return function(e) {
        const detailsSrc = window.document.querySelectorAll(".cell > details > .sourceCode");
        for (let i=0; i<detailsSrc.length; i++) {
          const details = detailsSrc[i].parentElement;
          if (show) {
            details.open = true;
          } else {
            details.removeAttribute("open");
          }
        }
        const cellCodeDivs = window.document.querySelectorAll(".cell > .sourceCode");
        const fromCls = show ? "hidden" : "unhidden";
        const toCls = show ? "unhidden" : "hidden";
        for (let i=0; i<cellCodeDivs.length; i++) {
          const codeDiv = cellCodeDivs[i];
          if (codeDiv.classList.contains(fromCls)) {
            codeDiv.classList.remove(fromCls);
            codeDiv.classList.add(toCls);
          } 
        }
        return false;
      }
    }
    const hideAllCode = window.document.getElementById("quarto-hide-all-code");
    if (hideAllCode) {
      hideAllCode.addEventListener("click", toggleCodeHandler(false));
    }
    const showAllCode = window.document.getElementById("quarto-show-all-code");
    if (showAllCode) {
      showAllCode.addEventListener("click", toggleCodeHandler(true));
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="../m01-euler_tour/01-concepts.html" class="pagination-link" aria-label="A Stroll, Seven Bridges, and a Mathematical Revolution">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text">A Stroll, Seven Bridges, and a Mathematical Revolution</span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="../m01-euler_tour/03-exercises.html" class="pagination-link" aria-label="Exercises">
        <span class="nav-page-text">Exercises</span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav><div class="modal fade" id="quarto-embedded-source-code-modal" tabindex="-1" aria-labelledby="quarto-embedded-source-code-modal-label" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable"><div class="modal-content"><div class="modal-header"><h5 class="modal-title" id="quarto-embedded-source-code-modal-label">Source Code</h5><button class="btn-close" data-bs-dismiss="modal"></button></div><div class="modal-body"><div class="">
<div class="sourceCode" id="cb26" data-shortcodes="false"><pre class="sourceCode markdown code-with-copy"><code class="sourceCode markdown"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="an">title:</span><span class="co"> Coding Networks in Python</span></span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a><span class="an">jupyter:</span><span class="co"> python3</span></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a><span class="an">execute:</span></span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a><span class="co">    enabled: true</span></span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a><span class="co">---</span></span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>Now that you understand the conceptual foundation from Euler's work, let's explore how to represent and analyze networks computationally. Given a network of any size, our goal is to create a function that can tell us whether the network has an Euler path or not.</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a><span class="in">```python</span></span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> has_euler_path(A):</span>
<span id="cb26-12"><a href="#cb26-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-13"><a href="#cb26-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if a graph has an Euler path based on node degrees.</span></span>
<span id="cb26-14"><a href="#cb26-14" aria-hidden="true" tabindex="-1"></a><span class="co">    Complete this function based on Euler's theorem.</span></span>
<span id="cb26-15"><a href="#cb26-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-16"><a href="#cb26-16" aria-hidden="true" tabindex="-1"></a><span class="co">    A: network (assumed to be an adjacency matrix)</span></span>
<span id="cb26-17"><a href="#cb26-17" aria-hidden="true" tabindex="-1"></a><span class="co">    return: True if the network has an Euler path, False otherwise</span></span>
<span id="cb26-18"><a href="#cb26-18" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-19"><a href="#cb26-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate degrees of all nodes</span></span>
<span id="cb26-20"><a href="#cb26-20" aria-hidden="true" tabindex="-1"></a>    degrees <span class="op">=</span> A.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-21"><a href="#cb26-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-22"><a href="#cb26-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count nodes with odd degrees</span></span>
<span id="cb26-23"><a href="#cb26-23" aria-hidden="true" tabindex="-1"></a>    odd_degree_count <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb26-24"><a href="#cb26-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> degree <span class="kw">in</span> degrees:</span>
<span id="cb26-25"><a href="#cb26-25" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> degree <span class="op">%</span> <span class="dv">2</span> <span class="op">!=</span> <span class="dv">0</span>:</span>
<span id="cb26-26"><a href="#cb26-26" aria-hidden="true" tabindex="-1"></a>            odd_degree_count <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb26-27"><a href="#cb26-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-28"><a href="#cb26-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># According to Euler's theorem, an Euler path exists if:</span></span>
<span id="cb26-29"><a href="#cb26-29" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 1. The graph is connected (we assume this for now)</span></span>
<span id="cb26-30"><a href="#cb26-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># 2. Exactly 0 or 2 nodes have odd degrees</span></span>
<span id="cb26-31"><a href="#cb26-31" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> odd_degree_count <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> odd_degree_count <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb26-32"><a href="#cb26-32" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-33"><a href="#cb26-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-34"><a href="#cb26-34" aria-hidden="true" tabindex="-1"></a>We'll work through both general network representations and apply them specifically to the Königsberg bridge problem.</span>
<span id="cb26-35"><a href="#cb26-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-36"><a href="#cb26-36" aria-hidden="true" tabindex="-1"></a><span class="fu">## Network Representations: From Pictures to Data Structures</span></span>
<span id="cb26-37"><a href="#cb26-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-38"><a href="#cb26-38" aria-hidden="true" tabindex="-1"></a>Consider this network with 5 nodes and 6 edges:</span>
<span id="cb26-39"><a href="#cb26-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-40"><a href="#cb26-40" aria-hidden="true" tabindex="-1"></a>::: {#fig-small-graph}</span>
<span id="cb26-41"><a href="#cb26-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-42"><a href="#cb26-42" aria-hidden="true" tabindex="-1"></a><span class="al">![](https://www.tandfonline.com/cms/asset/2820b951-1747-4621-802c-8d04263f106c/tcon_a_1707286_f0001_oc.jpg)</span>{width=200px}</span>
<span id="cb26-43"><a href="#cb26-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-44"><a href="#cb26-44" aria-hidden="true" tabindex="-1"></a>A small graph of five nodes and six edges.</span>
<span id="cb26-45"><a href="#cb26-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-46"><a href="#cb26-46" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-47"><a href="#cb26-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-48"><a href="#cb26-48" aria-hidden="true" tabindex="-1"></a>How do we represent this graph in a format that a computer can understand and manipulate? Just as Euler needed to abstract Königsberg's bridges, we need data structures that capture the network's essential connectivity while enabling efficient analysis.</span>
<span id="cb26-49"><a href="#cb26-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-50"><a href="#cb26-50" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-51"><a href="#cb26-51" aria-hidden="true" tabindex="-1"></a>The choice of representation can dramatically affect computational efficiency. For sparse networks (few edges), adjacency lists are memory-efficient. For dense networks or matrix operations, adjacency matrices are preferred.</span>
<span id="cb26-52"><a href="#cb26-52" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-53"><a href="#cb26-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-54"><a href="#cb26-54" aria-hidden="true" tabindex="-1"></a>Let's explore three fundamental approaches that form the backbone of all network algorithms.</span>
<span id="cb26-55"><a href="#cb26-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-56"><a href="#cb26-56" aria-hidden="true" tabindex="-1"></a><span class="fu">### Edge Table: The Direct Approach</span></span>
<span id="cb26-57"><a href="#cb26-57" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-58"><a href="#cb26-58" aria-hidden="true" tabindex="-1"></a>The edge table directly lists connections as pairs—the most intuitive way to store network data.</span>
<span id="cb26-59"><a href="#cb26-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-60"><a href="#cb26-60" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-61"><a href="#cb26-61" aria-hidden="true" tabindex="-1"></a>Edge tables are also called "edge lists" and are the most common format for storing large-scale network data in files. Social media platforms like Twitter and Facebook store billions of connections this way.</span>
<span id="cb26-62"><a href="#cb26-62" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-63"><a href="#cb26-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-66"><a href="#cb26-66" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-67"><a href="#cb26-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Each row represents one edge (connection between two nodes)</span></span>
<span id="cb26-68"><a href="#cb26-68" aria-hidden="true" tabindex="-1"></a>edges <span class="op">=</span> [</span>
<span id="cb26-69"><a href="#cb26-69" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">1</span>),  <span class="co"># Node 0 connects to Node 1</span></span>
<span id="cb26-70"><a href="#cb26-70" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">0</span>, <span class="dv">2</span>),  <span class="co"># Node 0 connects to Node 2</span></span>
<span id="cb26-71"><a href="#cb26-71" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">2</span>),  <span class="co"># Node 1 connects to Node 2</span></span>
<span id="cb26-72"><a href="#cb26-72" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">1</span>, <span class="dv">3</span>),  <span class="co"># Node 1 connects to Node 3</span></span>
<span id="cb26-73"><a href="#cb26-73" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">2</span>, <span class="dv">4</span>),  <span class="co"># Node 2 connects to Node 4</span></span>
<span id="cb26-74"><a href="#cb26-74" aria-hidden="true" tabindex="-1"></a>    (<span class="dv">3</span>, <span class="dv">4</span>)   <span class="co"># Node 3 connects to Node 4</span></span>
<span id="cb26-75"><a href="#cb26-75" aria-hidden="true" tabindex="-1"></a>]</span>
<span id="cb26-76"><a href="#cb26-76" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-77"><a href="#cb26-77" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Network has </span><span class="sc">{</span><span class="bu">len</span>(edges)<span class="sc">}</span><span class="ss"> edges"</span>)</span>
<span id="cb26-78"><a href="#cb26-78" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Edge list:"</span>, edges)</span>
<span id="cb26-79"><a href="#cb26-79" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-80"><a href="#cb26-80" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-81"><a href="#cb26-81" aria-hidden="true" tabindex="-1"></a>This mirrors how we'd naturally describe the network: "Node 0 connects to nodes 1 and 2, node 1 connects to nodes 0, 2, and 3..." It's the digital equivalent of Euler's original approach—simply listing which bridges connect which landmasses.</span>
<span id="cb26-82"><a href="#cb26-82" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-83"><a href="#cb26-83" aria-hidden="true" tabindex="-1"></a><span class="fu">### Adjacency List: The Neighborhood Map</span></span>
<span id="cb26-84"><a href="#cb26-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-85"><a href="#cb26-85" aria-hidden="true" tabindex="-1"></a>The adjacency list stores each node's neighbors in a dictionary—like a social network where each person has a list of friends.</span>
<span id="cb26-86"><a href="#cb26-86" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-87"><a href="#cb26-87" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-88"><a href="#cb26-88" aria-hidden="true" tabindex="-1"></a>Most graph algorithms prefer adjacency lists because they allow fast iteration over a node's neighbors. This is crucial for algorithms like breadth-first search or computing clustering coefficients.</span>
<span id="cb26-89"><a href="#cb26-89" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-90"><a href="#cb26-90" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-93"><a href="#cb26-93" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-94"><a href="#cb26-94" aria-hidden="true" tabindex="-1"></a><span class="co"># Define adjacency list directly as a dictionary</span></span>
<span id="cb26-95"><a href="#cb26-95" aria-hidden="true" tabindex="-1"></a>neighbors <span class="op">=</span> {</span>
<span id="cb26-96"><a href="#cb26-96" aria-hidden="true" tabindex="-1"></a>    <span class="dv">0</span>: [<span class="dv">1</span>, <span class="dv">2</span>],     <span class="co"># Node 0 connects to nodes 1 and 2</span></span>
<span id="cb26-97"><a href="#cb26-97" aria-hidden="true" tabindex="-1"></a>    <span class="dv">1</span>: [<span class="dv">0</span>, <span class="dv">2</span>, <span class="dv">3</span>],  <span class="co"># Node 1 connects to nodes 0, 2, and 3</span></span>
<span id="cb26-98"><a href="#cb26-98" aria-hidden="true" tabindex="-1"></a>    <span class="dv">2</span>: [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">4</span>],  <span class="co"># Node 2 connects to nodes 0, 1, and 4</span></span>
<span id="cb26-99"><a href="#cb26-99" aria-hidden="true" tabindex="-1"></a>    <span class="dv">3</span>: [<span class="dv">1</span>, <span class="dv">4</span>],     <span class="co"># Node 3 connects to nodes 1 and 4</span></span>
<span id="cb26-100"><a href="#cb26-100" aria-hidden="true" tabindex="-1"></a>    <span class="dv">4</span>: [<span class="dv">2</span>, <span class="dv">3</span>]      <span class="co"># Node 4 connects to nodes 2 and 3</span></span>
<span id="cb26-101"><a href="#cb26-101" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb26-102"><a href="#cb26-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-103"><a href="#cb26-103" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Adjacency list representation:"</span>)</span>
<span id="cb26-104"><a href="#cb26-104" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node, neighbor_list <span class="kw">in</span> neighbors.items():</span>
<span id="cb26-105"><a href="#cb26-105" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Node </span><span class="sc">{</span>node<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>neighbor_list<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-106"><a href="#cb26-106" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-107"><a href="#cb26-107" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-108"><a href="#cb26-108" aria-hidden="true" tabindex="-1"></a><span class="fu">### Adjacency Matrix</span></span>
<span id="cb26-109"><a href="#cb26-109" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-110"><a href="#cb26-110" aria-hidden="true" tabindex="-1"></a>The adjacency matrix uses a grid where entry (i,j) = 1 if nodes are connected—the mathematician's favorite representation.</span>
<span id="cb26-111"><a href="#cb26-111" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-112"><a href="#cb26-112" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-113"><a href="#cb26-113" aria-hidden="true" tabindex="-1"></a>Adjacency matrices enable powerful mathematical operations. Matrix multiplication reveals paths of different lengths, and eigenvalue analysis can uncover community structure. Google's PageRank algorithm fundamentally relies on matrix operations.</span>
<span id="cb26-114"><a href="#cb26-114" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-115"><a href="#cb26-115" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-118"><a href="#cb26-118" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-119"><a href="#cb26-119" aria-hidden="true" tabindex="-1"></a><span class="co"># Define adjacency matrix directly</span></span>
<span id="cb26-120"><a href="#cb26-120" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-121"><a href="#cb26-121" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-122"><a href="#cb26-122" aria-hidden="true" tabindex="-1"></a>matrix <span class="op">=</span> np.array([</span>
<span id="cb26-123"><a href="#cb26-123" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],  <span class="co"># Node 0 connects to nodes 1, 2</span></span>
<span id="cb26-124"><a href="#cb26-124" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>],  <span class="co"># Node 1 connects to nodes 0, 2, 3</span></span>
<span id="cb26-125"><a href="#cb26-125" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],  <span class="co"># Node 2 connects to nodes 0, 1, 4</span></span>
<span id="cb26-126"><a href="#cb26-126" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],  <span class="co"># Node 3 connects to nodes 1, 4</span></span>
<span id="cb26-127"><a href="#cb26-127" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>]   <span class="co"># Node 4 connects to nodes 2, 3</span></span>
<span id="cb26-128"><a href="#cb26-128" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb26-129"><a href="#cb26-129" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-130"><a href="#cb26-130" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Adjacency matrix:"</span>)</span>
<span id="cb26-131"><a href="#cb26-131" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(matrix)</span>
<span id="cb26-132"><a href="#cb26-132" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-133"><a href="#cb26-133" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-134"><a href="#cb26-134" aria-hidden="true" tabindex="-1"></a>Notice the symmetry: if node i connects to node j, then node j connects to node i (for undirected networks). This symmetry disappears in directed networks, where relationships can be one-way.</span>
<span id="cb26-135"><a href="#cb26-135" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-136"><a href="#cb26-136" aria-hidden="true" tabindex="-1"></a><span class="fu">## Node Degrees</span></span>
<span id="cb26-137"><a href="#cb26-137" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-138"><a href="#cb26-138" aria-hidden="true" tabindex="-1"></a>The degree of a node is the number of edges connected to it. This simple concept was central to Euler's proof—he realized that a valid bridge walk requires each landmass to have an even degree (except possibly the starting and ending points).</span>
<span id="cb26-139"><a href="#cb26-139" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-140"><a href="#cb26-140" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-141"><a href="#cb26-141" aria-hidden="true" tabindex="-1"></a>In Königsberg, all four landmasses had odd degree, making the bridge walk impossible. This insight—that global properties emerge from local structure—remains fundamental to network analysis today.</span>
<span id="cb26-142"><a href="#cb26-142" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-143"><a href="#cb26-143" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-144"><a href="#cb26-144" aria-hidden="true" tabindex="-1"></a>Here's how to compute degrees using each representation:</span>
<span id="cb26-145"><a href="#cb26-145" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-146"><a href="#cb26-146" aria-hidden="true" tabindex="-1"></a><span class="fu">### From Edge Table</span></span>
<span id="cb26-147"><a href="#cb26-147" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-148"><a href="#cb26-148" aria-hidden="true" tabindex="-1"></a>Count how many times each node appears in the edge list.</span>
<span id="cb26-149"><a href="#cb26-149" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-152"><a href="#cb26-152" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-153"><a href="#cb26-153" aria-hidden="true" tabindex="-1"></a>_degrees <span class="op">=</span> [<span class="dv">0</span>] <span class="op">*</span> <span class="dv">5</span></span>
<span id="cb26-154"><a href="#cb26-154" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> node1, node2 <span class="kw">in</span> edges:</span>
<span id="cb26-155"><a href="#cb26-155" aria-hidden="true" tabindex="-1"></a>    _degrees[node1] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb26-156"><a href="#cb26-156" aria-hidden="true" tabindex="-1"></a>    _degrees[node2] <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb26-157"><a href="#cb26-157" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Degrees from edge list:"</span>, _degrees)</span>
<span id="cb26-158"><a href="#cb26-158" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-159"><a href="#cb26-159" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-160"><a href="#cb26-160" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-161"><a href="#cb26-161" aria-hidden="true" tabindex="-1"></a>We increment the degree counter for both nodes in each edge because every edge contributes to two nodes' degrees. This is why the total degree always equals twice the number of edges.</span>
<span id="cb26-162"><a href="#cb26-162" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-163"><a href="#cb26-163" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-164"><a href="#cb26-164" aria-hidden="true" tabindex="-1"></a><span class="fu">### From Adjacency List</span></span>
<span id="cb26-165"><a href="#cb26-165" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-166"><a href="#cb26-166" aria-hidden="true" tabindex="-1"></a>Count the length of each node's neighbor list—the most direct approach.</span>
<span id="cb26-167"><a href="#cb26-167" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-170"><a href="#cb26-170" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-171"><a href="#cb26-171" aria-hidden="true" tabindex="-1"></a>_degrees <span class="op">=</span> [<span class="bu">len</span>(neighbors[i]) <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">5</span>)]</span>
<span id="cb26-172"><a href="#cb26-172" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Degrees from adjacency list:"</span>, _degrees)</span>
<span id="cb26-173"><a href="#cb26-173" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-174"><a href="#cb26-174" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-175"><a href="#cb26-175" aria-hidden="true" tabindex="-1"></a><span class="fu">### From Adjacency Matrix</span></span>
<span id="cb26-176"><a href="#cb26-176" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-177"><a href="#cb26-177" aria-hidden="true" tabindex="-1"></a>Sum each row (or column) of the matrix—leveraging vectorized operations.</span>
<span id="cb26-178"><a href="#cb26-178" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-181"><a href="#cb26-181" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-182"><a href="#cb26-182" aria-hidden="true" tabindex="-1"></a>_degrees <span class="op">=</span> matrix.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)  <span class="co"># Sum rows</span></span>
<span id="cb26-183"><a href="#cb26-183" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Degrees from adjacency matrix:"</span>, _degrees)</span>
<span id="cb26-184"><a href="#cb26-184" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-185"><a href="#cb26-185" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-186"><a href="#cb26-186" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-187"><a href="#cb26-187" aria-hidden="true" tabindex="-1"></a>For undirected networks, row sums equal column sums. For directed networks, row sums give out-degree (outgoing connections) while column sums give in-degree (incoming connections).</span>
<span id="cb26-188"><a href="#cb26-188" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-189"><a href="#cb26-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-190"><a href="#cb26-190" aria-hidden="true" tabindex="-1"></a><span class="fu">## Checking for Trails, Walks, and Paths</span></span>
<span id="cb26-191"><a href="#cb26-191" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-192"><a href="#cb26-192" aria-hidden="true" tabindex="-1"></a>Now that we understand how to represent networks and compute degrees, let's implement functions to verify whether a sequence of nodes represents a valid walk, trail, path, or cycle. These verification algorithms are essential for network analysis and implementing graph traversal algorithms.</span>
<span id="cb26-193"><a href="#cb26-193" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-194"><a href="#cb26-194" aria-hidden="true" tabindex="-1"></a><span class="fu">### Verifying a Walk</span></span>
<span id="cb26-195"><a href="#cb26-195" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-196"><a href="#cb26-196" aria-hidden="true" tabindex="-1"></a>A **walk** is the most permissive—we simply need to check that each consecutive pair of nodes is connected by an edge.</span>
<span id="cb26-197"><a href="#cb26-197" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-200"><a href="#cb26-200" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-201"><a href="#cb26-201" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_walk(sequence, adjacency_matrix):</span>
<span id="cb26-202"><a href="#cb26-202" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-203"><a href="#cb26-203" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if a sequence of nodes forms a valid walk.</span></span>
<span id="cb26-204"><a href="#cb26-204" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-205"><a href="#cb26-205" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb26-206"><a href="#cb26-206" aria-hidden="true" tabindex="-1"></a><span class="co">        sequence: List of node indices [v0, v1, v2, ...]</span></span>
<span id="cb26-207"><a href="#cb26-207" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array representing the graph</span></span>
<span id="cb26-208"><a href="#cb26-208" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-209"><a href="#cb26-209" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb26-210"><a href="#cb26-210" aria-hidden="true" tabindex="-1"></a><span class="co">        bool: True if sequence is a valid walk, False otherwise</span></span>
<span id="cb26-211"><a href="#cb26-211" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-212"><a href="#cb26-212" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sequence) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb26-213"><a href="#cb26-213" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span>  <span class="co"># Single node or empty sequence is trivially a walk</span></span>
<span id="cb26-214"><a href="#cb26-214" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-215"><a href="#cb26-215" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use NumPy vectorized operations for efficient edge checking</span></span>
<span id="cb26-216"><a href="#cb26-216" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> np.array(sequence)</span>
<span id="cb26-217"><a href="#cb26-217" aria-hidden="true" tabindex="-1"></a>    current_nodes <span class="op">=</span> sequence[:<span class="op">-</span><span class="dv">1</span>]  <span class="co"># All nodes except the last</span></span>
<span id="cb26-218"><a href="#cb26-218" aria-hidden="true" tabindex="-1"></a>    next_nodes <span class="op">=</span> sequence[<span class="dv">1</span>:]      <span class="co"># All nodes except the first</span></span>
<span id="cb26-219"><a href="#cb26-219" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-220"><a href="#cb26-220" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Simple but slower: for loop version (slower but more explicit)</span></span>
<span id="cb26-221"><a href="#cb26-221" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for i, j in zip(current_nodes, next_nodes):</span></span>
<span id="cb26-222"><a href="#cb26-222" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     if adjacency_matrix[i, j] == 0:</span></span>
<span id="cb26-223"><a href="#cb26-223" aria-hidden="true" tabindex="-1"></a>    <span class="co">#         return False</span></span>
<span id="cb26-224"><a href="#cb26-224" aria-hidden="true" tabindex="-1"></a>    <span class="co"># return True</span></span>
<span id="cb26-225"><a href="#cb26-225" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-226"><a href="#cb26-226" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check all edges at once using advanced indexing</span></span>
<span id="cb26-227"><a href="#cb26-227" aria-hidden="true" tabindex="-1"></a>    edges_exist <span class="op">=</span> adjacency_matrix[current_nodes, next_nodes]</span>
<span id="cb26-228"><a href="#cb26-228" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-229"><a href="#cb26-229" aria-hidden="true" tabindex="-1"></a>    <span class="co"># All edges must exist (all values must be 1)</span></span>
<span id="cb26-230"><a href="#cb26-230" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.<span class="bu">all</span>(edges_exist <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb26-231"><a href="#cb26-231" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-232"><a href="#cb26-232" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-233"><a href="#cb26-233" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with our sample network</span></span>
<span id="cb26-234"><a href="#cb26-234" aria-hidden="true" tabindex="-1"></a>test_sequence <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>]</span>
<span id="cb26-235"><a href="#cb26-235" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>test_sequence<span class="sc">}</span><span class="ss"> is a valid walk: </span><span class="sc">{</span>is_walk(test_sequence, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-236"><a href="#cb26-236" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-237"><a href="#cb26-237" aria-hidden="true" tabindex="-1"></a><span class="co"># Test an invalid walk</span></span>
<span id="cb26-238"><a href="#cb26-238" aria-hidden="true" tabindex="-1"></a>invalid_sequence <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">3</span>]  <span class="co"># No direct edge between 0 and 3</span></span>
<span id="cb26-239"><a href="#cb26-239" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>invalid_sequence<span class="sc">}</span><span class="ss"> is a valid walk: </span><span class="sc">{</span>is_walk(invalid_sequence, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-240"><a href="#cb26-240" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-241"><a href="#cb26-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-242"><a href="#cb26-242" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-243"><a href="#cb26-243" aria-hidden="true" tabindex="-1"></a>::: {.callout-note title="Mind the loops!"}</span>
<span id="cb26-244"><a href="#cb26-244" aria-hidden="true" tabindex="-1"></a>For loops in Python is the notorious source of computational bottlenecks.</span>
<span id="cb26-245"><a href="#cb26-245" aria-hidden="true" tabindex="-1"></a>Avoiding for loops significantly boosts the speed. In <span class="in">`is_walk`</span>, we use one for loop but you can avoid it by using NumPy's advanced indexing, i.e., <span class="in">`adjacency_matrix[(current_nodes, next_nodes)]`</span>. The way to think about this is that <span class="in">`(current_nodes, next_nodes)`</span> is a tuple of indices, acting as a multi-dimensional index.</span>
<span id="cb26-246"><a href="#cb26-246" aria-hidden="true" tabindex="-1"></a><span class="in">`adjacency_matrix[(current_nodes, next_nodes)]`</span> is 1d array of length the same as <span class="in">`current_nodes`</span> and <span class="in">`next_nodes`</span>. If the value is 0, then the edge does not exist. We can then check if all the values are not zero.</span>
<span id="cb26-247"><a href="#cb26-247" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-248"><a href="#cb26-248" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-249"><a href="#cb26-249" aria-hidden="true" tabindex="-1"></a><span class="fu">### Verifying a Trail</span></span>
<span id="cb26-250"><a href="#cb26-250" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-251"><a href="#cb26-251" aria-hidden="true" tabindex="-1"></a>A **trail** requires all edges to be distinct, but nodes can repeat.</span>
<span id="cb26-252"><a href="#cb26-252" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-255"><a href="#cb26-255" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-256"><a href="#cb26-256" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_trail(sequence, adjacency_matrix):</span>
<span id="cb26-257"><a href="#cb26-257" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-258"><a href="#cb26-258" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if a sequence of nodes forms a valid trail.</span></span>
<span id="cb26-259"><a href="#cb26-259" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-260"><a href="#cb26-260" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb26-261"><a href="#cb26-261" aria-hidden="true" tabindex="-1"></a><span class="co">        sequence: List of node indices [v0, v1, v2, ...]</span></span>
<span id="cb26-262"><a href="#cb26-262" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array representing the graph</span></span>
<span id="cb26-263"><a href="#cb26-263" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-264"><a href="#cb26-264" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb26-265"><a href="#cb26-265" aria-hidden="true" tabindex="-1"></a><span class="co">        bool: True if sequence is a valid trail, False otherwise</span></span>
<span id="cb26-266"><a href="#cb26-266" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-267"><a href="#cb26-267" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> is_walk(sequence, adjacency_matrix):</span>
<span id="cb26-268"><a href="#cb26-268" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Must be a valid walk first</span></span>
<span id="cb26-269"><a href="#cb26-269" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-270"><a href="#cb26-270" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sequence) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb26-271"><a href="#cb26-271" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb26-272"><a href="#cb26-272" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-273"><a href="#cb26-273" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Convert to numpy for efficient operations</span></span>
<span id="cb26-274"><a href="#cb26-274" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> np.array(sequence)</span>
<span id="cb26-275"><a href="#cb26-275" aria-hidden="true" tabindex="-1"></a>    current_nodes <span class="op">=</span> sequence[:<span class="op">-</span><span class="dv">1</span>]</span>
<span id="cb26-276"><a href="#cb26-276" aria-hidden="true" tabindex="-1"></a>    next_nodes <span class="op">=</span> sequence[<span class="dv">1</span>:]</span>
<span id="cb26-277"><a href="#cb26-277" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-278"><a href="#cb26-278" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use complex numbers to represent edges!</span></span>
<span id="cb26-279"><a href="#cb26-279" aria-hidden="true" tabindex="-1"></a>    <span class="co"># For undirected graph: smaller_node + 1j * larger_node</span></span>
<span id="cb26-280"><a href="#cb26-280" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This ensures edge (1,2) and (2,1) both become 1+2j</span></span>
<span id="cb26-281"><a href="#cb26-281" aria-hidden="true" tabindex="-1"></a>    edge_starts <span class="op">=</span> np.minimum(current_nodes, next_nodes)  <span class="co"># Real part</span></span>
<span id="cb26-282"><a href="#cb26-282" aria-hidden="true" tabindex="-1"></a>    edge_ends <span class="op">=</span> np.maximum(current_nodes, next_nodes)    <span class="co"># Imaginary part</span></span>
<span id="cb26-283"><a href="#cb26-283" aria-hidden="true" tabindex="-1"></a>    complex_edges <span class="op">=</span> edge_starts <span class="op">+</span> <span class="ot">1j</span> <span class="op">*</span> edge_ends</span>
<span id="cb26-284"><a href="#cb26-284" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-285"><a href="#cb26-285" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check uniqueness directly with NumPy</span></span>
<span id="cb26-286"><a href="#cb26-286" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(complex_edges) <span class="op">==</span> <span class="bu">len</span>(np.unique(complex_edges))</span>
<span id="cb26-287"><a href="#cb26-287" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-288"><a href="#cb26-288" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Alternative: Original for loop version (slower but more explicit)</span></span>
<span id="cb26-289"><a href="#cb26-289" aria-hidden="true" tabindex="-1"></a>    <span class="co"># used_edges = set()</span></span>
<span id="cb26-290"><a href="#cb26-290" aria-hidden="true" tabindex="-1"></a>    <span class="co"># for i in range(len(sequence) - 1):</span></span>
<span id="cb26-291"><a href="#cb26-291" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     current_node = sequence[i]</span></span>
<span id="cb26-292"><a href="#cb26-292" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     next_node = sequence[i + 1]</span></span>
<span id="cb26-293"><a href="#cb26-293" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     # Create edge tuple (smaller index first for undirected graphs)</span></span>
<span id="cb26-294"><a href="#cb26-294" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     edge = (min(current_node, next_node), max(current_node, next_node))</span></span>
<span id="cb26-295"><a href="#cb26-295" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     if edge in used_edges:</span></span>
<span id="cb26-296"><a href="#cb26-296" aria-hidden="true" tabindex="-1"></a>    <span class="co">#         return False  # Edge already used</span></span>
<span id="cb26-297"><a href="#cb26-297" aria-hidden="true" tabindex="-1"></a>    <span class="co">#     used_edges.add(edge)</span></span>
<span id="cb26-298"><a href="#cb26-298" aria-hidden="true" tabindex="-1"></a>    <span class="co"># return True</span></span>
<span id="cb26-299"><a href="#cb26-299" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-300"><a href="#cb26-300" aria-hidden="true" tabindex="-1"></a><span class="co"># Test trail verification</span></span>
<span id="cb26-301"><a href="#cb26-301" aria-hidden="true" tabindex="-1"></a>trail_sequence <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">2</span>]</span>
<span id="cb26-302"><a href="#cb26-302" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>trail_sequence<span class="sc">}</span><span class="ss"> is a valid trail: </span><span class="sc">{</span>is_trail(trail_sequence, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-303"><a href="#cb26-303" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-304"><a href="#cb26-304" aria-hidden="true" tabindex="-1"></a><span class="co"># Test invalid trail (reuses edge 1-2)</span></span>
<span id="cb26-305"><a href="#cb26-305" aria-hidden="true" tabindex="-1"></a>invalid_trail <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]</span>
<span id="cb26-306"><a href="#cb26-306" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>invalid_trail<span class="sc">}</span><span class="ss"> is a valid trail: </span><span class="sc">{</span>is_trail(invalid_trail, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-307"><a href="#cb26-307" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-308"><a href="#cb26-308" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-309"><a href="#cb26-309" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-310"><a href="#cb26-310" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-311"><a href="#cb26-311" aria-hidden="true" tabindex="-1"></a><span class="in">`np.unique`</span> is a powerful function that can handle complex numbers natively.</span>
<span id="cb26-312"><a href="#cb26-312" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-313"><a href="#cb26-313" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-314"><a href="#cb26-314" aria-hidden="true" tabindex="-1"></a>::: {.callout-note title="Complex Numbers for Edge Representation"}</span>
<span id="cb26-315"><a href="#cb26-315" aria-hidden="true" tabindex="-1"></a>We use complex numbers to represent edges! Each edge becomes <span class="in">`smaller_node + 1j * larger_node`</span>. For example, edge (1,2) becomes <span class="in">`1+2j`</span>, and edge (2,1) also becomes <span class="in">`1+2j`</span> (normalized).</span>
<span id="cb26-316"><a href="#cb26-316" aria-hidden="true" tabindex="-1"></a>Think of complex numbers as natural 2D coordinates for representing node pairs.</span>
<span id="cb26-317"><a href="#cb26-317" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-318"><a href="#cb26-318" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-319"><a href="#cb26-319" aria-hidden="true" tabindex="-1"></a><span class="fu">### Verifying a Path</span></span>
<span id="cb26-320"><a href="#cb26-320" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-321"><a href="#cb26-321" aria-hidden="true" tabindex="-1"></a>A **path** requires all nodes (except possibly start/end for cycles) to be distinct.</span>
<span id="cb26-322"><a href="#cb26-322" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-325"><a href="#cb26-325" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-326"><a href="#cb26-326" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> is_path(sequence, adjacency_matrix):</span>
<span id="cb26-327"><a href="#cb26-327" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-328"><a href="#cb26-328" aria-hidden="true" tabindex="-1"></a><span class="co">    Check if a sequence of nodes forms a valid path.</span></span>
<span id="cb26-329"><a href="#cb26-329" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-330"><a href="#cb26-330" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb26-331"><a href="#cb26-331" aria-hidden="true" tabindex="-1"></a><span class="co">        sequence: List of node indices [v0, v1, v2, ...]</span></span>
<span id="cb26-332"><a href="#cb26-332" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array representing the graph</span></span>
<span id="cb26-333"><a href="#cb26-333" aria-hidden="true" tabindex="-1"></a><span class="co">        allow_cycle: If True, allows start node = end node (cycle)</span></span>
<span id="cb26-334"><a href="#cb26-334" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-335"><a href="#cb26-335" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb26-336"><a href="#cb26-336" aria-hidden="true" tabindex="-1"></a><span class="co">        bool: True if sequence is a valid path, False otherwise</span></span>
<span id="cb26-337"><a href="#cb26-337" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-338"><a href="#cb26-338" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> is_walk(sequence, adjacency_matrix):</span>
<span id="cb26-339"><a href="#cb26-339" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Must be a valid walk first</span></span>
<span id="cb26-340"><a href="#cb26-340" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-341"><a href="#cb26-341" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(sequence) <span class="op">&lt;</span> <span class="dv">2</span>:</span>
<span id="cb26-342"><a href="#cb26-342" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span></span>
<span id="cb26-343"><a href="#cb26-343" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-344"><a href="#cb26-344" aria-hidden="true" tabindex="-1"></a>    sequence <span class="op">=</span> np.array(sequence)</span>
<span id="cb26-345"><a href="#cb26-345" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-346"><a href="#cb26-346" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="bu">len</span>(sequence) <span class="op">==</span> <span class="bu">len</span>(np.unique(sequence))</span>
<span id="cb26-347"><a href="#cb26-347" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-348"><a href="#cb26-348" aria-hidden="true" tabindex="-1"></a><span class="co"># Test path verification</span></span>
<span id="cb26-349"><a href="#cb26-349" aria-hidden="true" tabindex="-1"></a>path_sequence <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb26-350"><a href="#cb26-350" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>path_sequence<span class="sc">}</span><span class="ss"> is a valid path: </span><span class="sc">{</span>is_path(path_sequence, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-351"><a href="#cb26-351" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-352"><a href="#cb26-352" aria-hidden="true" tabindex="-1"></a><span class="co"># Test invalid path (repeats node 1)</span></span>
<span id="cb26-353"><a href="#cb26-353" aria-hidden="true" tabindex="-1"></a>invalid_path <span class="op">=</span> [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">1</span>, <span class="dv">3</span>]</span>
<span id="cb26-354"><a href="#cb26-354" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Sequence </span><span class="sc">{</span>invalid_path<span class="sc">}</span><span class="ss"> is a valid path: </span><span class="sc">{</span>is_path(invalid_path, matrix)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-355"><a href="#cb26-355" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-356"><a href="#cb26-356" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-357"><a href="#cb26-357" aria-hidden="true" tabindex="-1"></a><span class="fu">## Connected Components</span></span>
<span id="cb26-358"><a href="#cb26-358" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-359"><a href="#cb26-359" aria-hidden="true" tabindex="-1"></a>Connected components are the maximal sets of nodes where every pair is connected by some path. For Euler path analysis, this is crucial—an Euler path can only exist if the entire graph forms a single connected component (or if we're only considering the component containing edges).</span>
<span id="cb26-360"><a href="#cb26-360" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-361"><a href="#cb26-361" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-362"><a href="#cb26-362" aria-hidden="true" tabindex="-1"></a>In Königsberg, all landmasses were connected by bridges, forming one component. If one landmass were isolated, no Euler path could traverse the entire city. This connectivity requirement is the first condition in Euler's theorem.</span>
<span id="cb26-363"><a href="#cb26-363" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-364"><a href="#cb26-364" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-365"><a href="#cb26-365" aria-hidden="true" tabindex="-1"></a><span class="fu">### The Algorithm: Depth-First Search</span></span>
<span id="cb26-366"><a href="#cb26-366" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-367"><a href="#cb26-367" aria-hidden="true" tabindex="-1"></a>A simple way to find connected components is to systematically explore from each unvisited node using depth-first search (DFS). This works because DFS can only reach nodes that are connected through some path.</span>
<span id="cb26-368"><a href="#cb26-368" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-369"><a href="#cb26-369" aria-hidden="true" tabindex="-1"></a>**Algorithm steps:**</span>
<span id="cb26-370"><a href="#cb26-370" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>Mark all nodes as unvisited</span>
<span id="cb26-371"><a href="#cb26-371" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>For each unvisited node:</span>
<span id="cb26-372"><a href="#cb26-372" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Start a new component</span>
<span id="cb26-373"><a href="#cb26-373" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Use DFS to explore all reachable nodes</span>
<span id="cb26-374"><a href="#cb26-374" aria-hidden="true" tabindex="-1"></a><span class="ss">   - </span>Add all reached nodes to this component</span>
<span id="cb26-375"><a href="#cb26-375" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>Return the list of components</span>
<span id="cb26-376"><a href="#cb26-376" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-379"><a href="#cb26-379" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-380"><a href="#cb26-380" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> connected_components(adjacency_matrix):</span>
<span id="cb26-381"><a href="#cb26-381" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-382"><a href="#cb26-382" aria-hidden="true" tabindex="-1"></a><span class="co">    Find connected components in an undirected graph using adjacency matrix.</span></span>
<span id="cb26-383"><a href="#cb26-383" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-384"><a href="#cb26-384" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb26-385"><a href="#cb26-385" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array (square)</span></span>
<span id="cb26-386"><a href="#cb26-386" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-387"><a href="#cb26-387" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb26-388"><a href="#cb26-388" aria-hidden="true" tabindex="-1"></a><span class="co">        List of lists, each sublist contains node indices in a component</span></span>
<span id="cb26-389"><a href="#cb26-389" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-390"><a href="#cb26-390" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb26-391"><a href="#cb26-391" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> adjacency_matrix.shape[<span class="dv">0</span>]</span>
<span id="cb26-392"><a href="#cb26-392" aria-hidden="true" tabindex="-1"></a>    visited <span class="op">=</span> np.zeros(n, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb26-393"><a href="#cb26-393" aria-hidden="true" tabindex="-1"></a>    components <span class="op">=</span> []</span>
<span id="cb26-394"><a href="#cb26-394" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-395"><a href="#cb26-395" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> dfs(node, component):</span>
<span id="cb26-396"><a href="#cb26-396" aria-hidden="true" tabindex="-1"></a>        <span class="co">"""Depth-first search to explore a component"""</span></span>
<span id="cb26-397"><a href="#cb26-397" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Mark the current node as visited and add it to current component</span></span>
<span id="cb26-398"><a href="#cb26-398" aria-hidden="true" tabindex="-1"></a>        visited[node] <span class="op">=</span> <span class="va">True</span></span>
<span id="cb26-399"><a href="#cb26-399" aria-hidden="true" tabindex="-1"></a>        component.append(node)</span>
<span id="cb26-400"><a href="#cb26-400" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-401"><a href="#cb26-401" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find all neighbors of the current node using vectorized operation</span></span>
<span id="cb26-402"><a href="#cb26-402" aria-hidden="true" tabindex="-1"></a>        neighbors <span class="op">=</span> np.where(adjacency_matrix[node] <span class="op">&gt;</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb26-403"><a href="#cb26-403" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-404"><a href="#cb26-404" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Recursively visit unvisited neighbors</span></span>
<span id="cb26-405"><a href="#cb26-405" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> neighbor <span class="kw">in</span> neighbors:</span>
<span id="cb26-406"><a href="#cb26-406" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> <span class="kw">not</span> visited[neighbor]:</span>
<span id="cb26-407"><a href="#cb26-407" aria-hidden="true" tabindex="-1"></a>                dfs(neighbor, component)</span>
<span id="cb26-408"><a href="#cb26-408" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-409"><a href="#cb26-409" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Main algorithm: iterate through all nodes</span></span>
<span id="cb26-410"><a href="#cb26-410" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> <span class="bu">range</span>(n):</span>
<span id="cb26-411"><a href="#cb26-411" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> visited[v]:  <span class="co"># Found a new component</span></span>
<span id="cb26-412"><a href="#cb26-412" aria-hidden="true" tabindex="-1"></a>            component <span class="op">=</span> []</span>
<span id="cb26-413"><a href="#cb26-413" aria-hidden="true" tabindex="-1"></a>            dfs(v, component)  <span class="co"># Explore entire component</span></span>
<span id="cb26-414"><a href="#cb26-414" aria-hidden="true" tabindex="-1"></a>            components.append(component)</span>
<span id="cb26-415"><a href="#cb26-415" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-416"><a href="#cb26-416" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> components</span>
<span id="cb26-417"><a href="#cb26-417" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-418"><a href="#cb26-418" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with our original connected graph</span></span>
<span id="cb26-419"><a href="#cb26-419" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Testing with connected graph:"</span>)</span>
<span id="cb26-420"><a href="#cb26-420" aria-hidden="true" tabindex="-1"></a>components <span class="op">=</span> connected_components(matrix)</span>
<span id="cb26-421"><a href="#cb26-421" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Connected components:"</span>, components)</span>
<span id="cb26-422"><a href="#cb26-422" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of components: </span><span class="sc">{</span><span class="bu">len</span>(components)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-423"><a href="#cb26-423" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-424"><a href="#cb26-424" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a disconnected graph to demonstrate multiple components</span></span>
<span id="cb26-425"><a href="#cb26-425" aria-hidden="true" tabindex="-1"></a>disconnected_matrix <span class="op">=</span> np.array([</span>
<span id="cb26-426"><a href="#cb26-426" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],  <span class="co"># Component 1: nodes 0,1,2</span></span>
<span id="cb26-427"><a href="#cb26-427" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>],  </span>
<span id="cb26-428"><a href="#cb26-428" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>],  </span>
<span id="cb26-429"><a href="#cb26-429" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>],  <span class="co"># Component 2: nodes 3,4</span></span>
<span id="cb26-430"><a href="#cb26-430" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>]   </span>
<span id="cb26-431"><a href="#cb26-431" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb26-432"><a href="#cb26-432" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-433"><a href="#cb26-433" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">Testing with disconnected graph:"</span>)</span>
<span id="cb26-434"><a href="#cb26-434" aria-hidden="true" tabindex="-1"></a>disconnected_components <span class="op">=</span> connected_components(disconnected_matrix)</span>
<span id="cb26-435"><a href="#cb26-435" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Connected components:"</span>, disconnected_components)</span>
<span id="cb26-436"><a href="#cb26-436" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f"Number of components: </span><span class="sc">{</span><span class="bu">len</span>(disconnected_components)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-437"><a href="#cb26-437" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-438"><a href="#cb26-438" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-439"><a href="#cb26-439" aria-hidden="true" tabindex="-1"></a>::: {.column-margin}</span>
<span id="cb26-440"><a href="#cb26-440" aria-hidden="true" tabindex="-1"></a>DFS naturally explores as "deep" as possible before backtracking. This makes it perfect for component finding because once we start exploring from a node, we want to find ALL nodes in its component before moving to the next component.</span>
<span id="cb26-441"><a href="#cb26-441" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-442"><a href="#cb26-442" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-443"><a href="#cb26-443" aria-hidden="true" tabindex="-1"></a><span class="fu">### Improved Euler Path Checker</span></span>
<span id="cb26-444"><a href="#cb26-444" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-445"><a href="#cb26-445" aria-hidden="true" tabindex="-1"></a>Now we can enhance our Euler path function to include the connectivity requirement:</span>
<span id="cb26-446"><a href="#cb26-446" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-449"><a href="#cb26-449" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-450"><a href="#cb26-450" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> has_euler_path_complete(adjacency_matrix):</span>
<span id="cb26-451"><a href="#cb26-451" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""</span></span>
<span id="cb26-452"><a href="#cb26-452" aria-hidden="true" tabindex="-1"></a><span class="co">    Complete Euler path checker with connectivity verification.</span></span>
<span id="cb26-453"><a href="#cb26-453" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb26-454"><a href="#cb26-454" aria-hidden="true" tabindex="-1"></a><span class="co">    Args:</span></span>
<span id="cb26-455"><a href="#cb26-455" aria-hidden="true" tabindex="-1"></a><span class="co">        adjacency_matrix: 2D numpy array representing the graph</span></span>
<span id="cb26-456"><a href="#cb26-456" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb26-457"><a href="#cb26-457" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb26-458"><a href="#cb26-458" aria-hidden="true" tabindex="-1"></a><span class="co">        bool: True if graph has an Euler path, False otherwise</span></span>
<span id="cb26-459"><a href="#cb26-459" aria-hidden="true" tabindex="-1"></a><span class="co">    """</span></span>
<span id="cb26-460"><a href="#cb26-460" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if graph is connected (ignoring isolated nodes)</span></span>
<span id="cb26-461"><a href="#cb26-461" aria-hidden="true" tabindex="-1"></a>    components <span class="op">=</span> connected_components(adjacency_matrix)</span>
<span id="cb26-462"><a href="#cb26-462" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-463"><a href="#cb26-463" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find nodes with at least one edge (degree &gt; 0)</span></span>
<span id="cb26-464"><a href="#cb26-464" aria-hidden="true" tabindex="-1"></a>    degrees <span class="op">=</span> adjacency_matrix.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-465"><a href="#cb26-465" aria-hidden="true" tabindex="-1"></a>    non_isolated_nodes <span class="op">=</span> np.where(degrees <span class="op">&gt;</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb26-466"><a href="#cb26-466" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-467"><a href="#cb26-467" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(non_isolated_nodes) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb26-468"><a href="#cb26-468" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">True</span>  <span class="co"># Empty graph has Euler path trivially</span></span>
<span id="cb26-469"><a href="#cb26-469" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-470"><a href="#cb26-470" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Check if all non-isolated nodes are in the same component</span></span>
<span id="cb26-471"><a href="#cb26-471" aria-hidden="true" tabindex="-1"></a>    component_with_edges <span class="op">=</span> <span class="va">None</span></span>
<span id="cb26-472"><a href="#cb26-472" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> component <span class="kw">in</span> components:</span>
<span id="cb26-473"><a href="#cb26-473" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> non_isolated_nodes[<span class="dv">0</span>] <span class="kw">in</span> component:</span>
<span id="cb26-474"><a href="#cb26-474" aria-hidden="true" tabindex="-1"></a>            component_with_edges <span class="op">=</span> <span class="bu">set</span>(component)</span>
<span id="cb26-475"><a href="#cb26-475" aria-hidden="true" tabindex="-1"></a>            <span class="cf">break</span></span>
<span id="cb26-476"><a href="#cb26-476" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-477"><a href="#cb26-477" aria-hidden="true" tabindex="-1"></a>    <span class="co"># All nodes with edges must be in the same component</span></span>
<span id="cb26-478"><a href="#cb26-478" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="kw">not</span> <span class="bu">all</span>(node <span class="kw">in</span> component_with_edges <span class="cf">for</span> node <span class="kw">in</span> non_isolated_nodes):</span>
<span id="cb26-479"><a href="#cb26-479" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">False</span>  <span class="co"># Graph is disconnected</span></span>
<span id="cb26-480"><a href="#cb26-480" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-481"><a href="#cb26-481" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Count nodes with odd degrees (among non-isolated nodes)</span></span>
<span id="cb26-482"><a href="#cb26-482" aria-hidden="true" tabindex="-1"></a>    non_isolated_degrees <span class="op">=</span> degrees[non_isolated_nodes]</span>
<span id="cb26-483"><a href="#cb26-483" aria-hidden="true" tabindex="-1"></a>    odd_degree_count <span class="op">=</span> np.<span class="bu">sum</span>(non_isolated_degrees <span class="op">%</span> <span class="dv">2</span>)</span>
<span id="cb26-484"><a href="#cb26-484" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-485"><a href="#cb26-485" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Euler's theorem: exactly 0 or 2 nodes with odd degrees</span></span>
<span id="cb26-486"><a href="#cb26-486" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> odd_degree_count <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> odd_degree_count <span class="op">==</span> <span class="dv">2</span></span>
<span id="cb26-487"><a href="#cb26-487" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-488"><a href="#cb26-488" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with connected graph</span></span>
<span id="cb26-489"><a href="#cb26-489" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Connected graph has Euler path:"</span>, has_euler_path_complete(matrix))</span>
<span id="cb26-490"><a href="#cb26-490" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-491"><a href="#cb26-491" aria-hidden="true" tabindex="-1"></a><span class="co"># Test with disconnected graph</span></span>
<span id="cb26-492"><a href="#cb26-492" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Disconnected graph has Euler path:"</span>, has_euler_path_complete(disconnected_matrix))</span>
<span id="cb26-493"><a href="#cb26-493" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-494"><a href="#cb26-494" aria-hidden="true" tabindex="-1"></a><span class="co"># Test the classic Königsberg bridge problem (all odd degrees)</span></span>
<span id="cb26-495"><a href="#cb26-495" aria-hidden="true" tabindex="-1"></a>konigsberg <span class="op">=</span> np.array([</span>
<span id="cb26-496"><a href="#cb26-496" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>],  <span class="co"># Landmass 0 connects to all others (degree 3)</span></span>
<span id="cb26-497"><a href="#cb26-497" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>],  <span class="co"># Landmass 1 connects to all others (degree 3)</span></span>
<span id="cb26-498"><a href="#cb26-498" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>],  <span class="co"># Landmass 2 connects to all others (degree 3)</span></span>
<span id="cb26-499"><a href="#cb26-499" aria-hidden="true" tabindex="-1"></a>    [<span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">1</span>, <span class="dv">0</span>]   <span class="co"># Landmass 3 connects to all others (degree 3)</span></span>
<span id="cb26-500"><a href="#cb26-500" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb26-501"><a href="#cb26-501" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"Königsberg bridges have Euler path:"</span>, has_euler_path_complete(konigsberg))</span>
<span id="cb26-502"><a href="#cb26-502" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-503"><a href="#cb26-503" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-504"><a href="#cb26-504" aria-hidden="true" tabindex="-1"></a>::: {.callout-important title="Why Connectivity Matters"}</span>
<span id="cb26-505"><a href="#cb26-505" aria-hidden="true" tabindex="-1"></a>Even if a graph has exactly 2 odd-degree nodes, an Euler path cannot exist if those nodes are in different connected components. You cannot traverse from one component to another without existing edges, making a single continuous path impossible.</span>
<span id="cb26-506"><a href="#cb26-506" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-507"><a href="#cb26-507" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-508"><a href="#cb26-508" aria-hidden="true" tabindex="-1"></a><span class="fu">### Visualizing Component Structure</span></span>
<span id="cb26-509"><a href="#cb26-509" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-510"><a href="#cb26-510" aria-hidden="true" tabindex="-1"></a>Understanding component structure helps debug complex networks:</span>
<span id="cb26-511"><a href="#cb26-511" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-514"><a href="#cb26-514" aria-hidden="true" tabindex="-1"></a><span class="in">```{python}</span></span>
<span id="cb26-515"><a href="#cb26-515" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> analyze_graph_structure(adjacency_matrix):</span>
<span id="cb26-516"><a href="#cb26-516" aria-hidden="true" tabindex="-1"></a>    <span class="co">"""Comprehensive analysis of graph structure for Euler path feasibility."""</span></span>
<span id="cb26-517"><a href="#cb26-517" aria-hidden="true" tabindex="-1"></a>    n <span class="op">=</span> adjacency_matrix.shape[<span class="dv">0</span>]</span>
<span id="cb26-518"><a href="#cb26-518" aria-hidden="true" tabindex="-1"></a>    degrees <span class="op">=</span> adjacency_matrix.<span class="bu">sum</span>(axis<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb26-519"><a href="#cb26-519" aria-hidden="true" tabindex="-1"></a>    components <span class="op">=</span> connected_components(adjacency_matrix)</span>
<span id="cb26-520"><a href="#cb26-520" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-521"><a href="#cb26-521" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"Graph Analysis:"</span>)</span>
<span id="cb26-522"><a href="#cb26-522" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"- Total nodes: </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-523"><a href="#cb26-523" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"- Total edges: </span><span class="sc">{</span>adjacency_matrix<span class="sc">.</span><span class="bu">sum</span>() <span class="op">//</span> <span class="dv">2</span><span class="sc">}</span><span class="ss">"</span>)  <span class="co"># Divide by 2 for undirected</span></span>
<span id="cb26-524"><a href="#cb26-524" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f"- Connected components: </span><span class="sc">{</span><span class="bu">len</span>(components)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-525"><a href="#cb26-525" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-526"><a href="#cb26-526" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Analyze each component</span></span>
<span id="cb26-527"><a href="#cb26-527" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> i, component <span class="kw">in</span> <span class="bu">enumerate</span>(components):</span>
<span id="cb26-528"><a href="#cb26-528" aria-hidden="true" tabindex="-1"></a>        component_degrees <span class="op">=</span> degrees[component]</span>
<span id="cb26-529"><a href="#cb26-529" aria-hidden="true" tabindex="-1"></a>        odd_count <span class="op">=</span> np.<span class="bu">sum</span>(component_degrees <span class="op">%</span> <span class="dv">2</span>)</span>
<span id="cb26-530"><a href="#cb26-530" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-531"><a href="#cb26-531" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Component </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: nodes </span><span class="sc">{</span>component<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-532"><a href="#cb26-532" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  - Size: </span><span class="sc">{</span><span class="bu">len</span>(component)<span class="sc">}</span><span class="ss"> nodes"</span>)</span>
<span id="cb26-533"><a href="#cb26-533" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  - Node degrees: </span><span class="sc">{</span><span class="bu">dict</span>(<span class="bu">zip</span>(component, component_degrees))<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-534"><a href="#cb26-534" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  - Odd degree nodes: </span><span class="sc">{</span>odd_count<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-535"><a href="#cb26-535" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"  - Has Euler path: </span><span class="sc">{</span>odd_count <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> odd_count <span class="op">==</span> <span class="dv">2</span><span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-536"><a href="#cb26-536" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb26-537"><a href="#cb26-537" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Overall Euler path conclusion</span></span>
<span id="cb26-538"><a href="#cb26-538" aria-hidden="true" tabindex="-1"></a>    non_isolated <span class="op">=</span> np.where(degrees <span class="op">&gt;</span> <span class="dv">0</span>)[<span class="dv">0</span>]</span>
<span id="cb26-539"><a href="#cb26-539" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(non_isolated) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb26-540"><a href="#cb26-540" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check if all non-isolated nodes are in same component</span></span>
<span id="cb26-541"><a href="#cb26-541" aria-hidden="true" tabindex="-1"></a>        main_component <span class="op">=</span> <span class="va">None</span></span>
<span id="cb26-542"><a href="#cb26-542" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> comp <span class="kw">in</span> components:</span>
<span id="cb26-543"><a href="#cb26-543" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> non_isolated[<span class="dv">0</span>] <span class="kw">in</span> comp:</span>
<span id="cb26-544"><a href="#cb26-544" aria-hidden="true" tabindex="-1"></a>                main_component <span class="op">=</span> <span class="bu">set</span>(comp)</span>
<span id="cb26-545"><a href="#cb26-545" aria-hidden="true" tabindex="-1"></a>                <span class="cf">break</span></span>
<span id="cb26-546"><a href="#cb26-546" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-547"><a href="#cb26-547" aria-hidden="true" tabindex="-1"></a>        connected <span class="op">=</span> <span class="bu">all</span>(node <span class="kw">in</span> main_component <span class="cf">for</span> node <span class="kw">in</span> non_isolated)</span>
<span id="cb26-548"><a href="#cb26-548" aria-hidden="true" tabindex="-1"></a>        odd_total <span class="op">=</span> np.<span class="bu">sum</span>(degrees[non_isolated] <span class="op">%</span> <span class="dv">2</span>)</span>
<span id="cb26-549"><a href="#cb26-549" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb26-550"><a href="#cb26-550" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"</span><span class="ch">\n</span><span class="ss">Overall Euler Path Analysis:"</span>)</span>
<span id="cb26-551"><a href="#cb26-551" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"- All edges connected: </span><span class="sc">{</span>connected<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-552"><a href="#cb26-552" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"- Total odd degree nodes: </span><span class="sc">{</span>odd_total<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-553"><a href="#cb26-553" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f"- Has Euler path: </span><span class="sc">{</span>connected <span class="kw">and</span> (odd_total <span class="op">==</span> <span class="dv">0</span> <span class="kw">or</span> odd_total <span class="op">==</span> <span class="dv">2</span>)<span class="sc">}</span><span class="ss">"</span>)</span>
<span id="cb26-554"><a href="#cb26-554" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-555"><a href="#cb26-555" aria-hidden="true" tabindex="-1"></a><span class="co"># Analyze our example graphs</span></span>
<span id="cb26-556"><a href="#cb26-556" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"=== Original Connected Graph ==="</span>)</span>
<span id="cb26-557"><a href="#cb26-557" aria-hidden="true" tabindex="-1"></a>analyze_graph_structure(matrix)</span>
<span id="cb26-558"><a href="#cb26-558" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-559"><a href="#cb26-559" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Disconnected Graph ==="</span>)</span>
<span id="cb26-560"><a href="#cb26-560" aria-hidden="true" tabindex="-1"></a>analyze_graph_structure(disconnected_matrix)</span>
<span id="cb26-561"><a href="#cb26-561" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-562"><a href="#cb26-562" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">"</span><span class="ch">\n</span><span class="st">=== Königsberg Bridges ==="</span>)</span>
<span id="cb26-563"><a href="#cb26-563" aria-hidden="true" tabindex="-1"></a>analyze_graph_structure(konigsberg)</span>
<span id="cb26-564"><a href="#cb26-564" aria-hidden="true" tabindex="-1"></a><span class="in">```</span></span>
<span id="cb26-565"><a href="#cb26-565" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-566"><a href="#cb26-566" aria-hidden="true" tabindex="-1"></a><span class="fu">## Summary</span></span>
<span id="cb26-567"><a href="#cb26-567" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-568"><a href="#cb26-568" aria-hidden="true" tabindex="-1"></a>You now understand how to:</span>
<span id="cb26-569"><a href="#cb26-569" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-570"><a href="#cb26-570" aria-hidden="true" tabindex="-1"></a><span class="ss">1. </span>**Represent networks** using edge lists, adjacency lists, and adjacency matrices—each optimized for different computational tasks</span>
<span id="cb26-571"><a href="#cb26-571" aria-hidden="true" tabindex="-1"></a><span class="ss">2. </span>**Compute node degrees** efficiently using vectorized operations across all representations</span>
<span id="cb26-572"><a href="#cb26-572" aria-hidden="true" tabindex="-1"></a><span class="ss">3. </span>**Verify walks, trails, paths, and cycles** with robust algorithms that handle edge cases</span>
<span id="cb26-573"><a href="#cb26-573" aria-hidden="true" tabindex="-1"></a><span class="ss">4. </span>**Find connected components** using depth-first search to identify disconnected parts of networks</span>
<span id="cb26-574"><a href="#cb26-574" aria-hidden="true" tabindex="-1"></a><span class="ss">5. </span>**Apply Euler's theorem completely** by checking both degree conditions and connectivity requirements</span>
<span id="cb26-575"><a href="#cb26-575" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-576"><a href="#cb26-576" aria-hidden="true" tabindex="-1"></a>::: {.callout-tip title="Computational Complexity"}</span>
<span id="cb26-577"><a href="#cb26-577" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Degree calculation: O(n²) for adjacency matrix, O(E) for edge list, O(1) for adjacency list</span>
<span id="cb26-578"><a href="#cb26-578" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Walk verification: O(k) where k is sequence length</span>
<span id="cb26-579"><a href="#cb26-579" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Connected components: O(n²) for adjacency matrix representation using DFS</span>
<span id="cb26-580"><a href="#cb26-580" aria-hidden="true" tabindex="-1"></a><span class="ss">- </span>Complete Euler path check: O(n²) dominated by connectivity check</span>
<span id="cb26-581"><a href="#cb26-581" aria-hidden="true" tabindex="-1"></a>:::</span>
<span id="cb26-582"><a href="#cb26-582" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-583"><a href="#cb26-583" aria-hidden="true" tabindex="-1"></a>These fundamental algorithms form the building blocks for more sophisticated network analysis. Whether you're analyzing social networks, transportation systems, or molecular structures, these core concepts of connectivity, traversal, and structural analysis remain essential.</span>
<span id="cb26-584"><a href="#cb26-584" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-585"><a href="#cb26-585" aria-hidden="true" tabindex="-1"></a>From Euler's original insight about Königsberg's bridges to modern network science, the mathematical principles you've implemented here continue to solve real-world problems—from GPS routing algorithms to understanding brain connectivity patterns.</span>
</code><button title="Copy to Clipboard" class="code-copy-button" data-in-quarto-modal=""><i class="bi"></i></button></pre></div>
</div></div></div></div></div>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2024, Sadamori Kojaku</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    <div class="toc-actions"><ul><li><a href="https://github.com/skojaku/adv-net-sci/edit/main/m01-euler_tour/02-coding.qmd" class="toc-action"><i class="bi bi-github"></i>Edit this page</a></li><li><a href="https://github.com/skojaku/adv-net-sci/issues/new" class="toc-action"><i class="bi empty"></i>Report an issue</a></li></ul></div></div>
    <div class="nav-footer-right">
      <ul class="footer-items list-unstyled">
    <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/skojaku/adv-net-sci">
      <i class="bi bi-github" role="img">
</i> 
    </a>
  </li>  
</ul>
    </div>
  </div>
</footer>




</body></html>