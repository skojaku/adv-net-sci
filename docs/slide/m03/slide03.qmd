---
format:
  revealjs:
    slide-number: true
    chalkboard:
      buttons: true
    preview-links: auto
    css: css/style.css
  html:
    code-fold: true
    code-tools: true
highlight-style: oblivion
execute:
    enabled: true
    echo: false
---

# Module 03: Network Robustness

:::: {.columns}

::: {.column width="50%"}
Advanced Topics in Network Science

Sadamori Kojaku

skojaku@binghamton.edu

:::

::: {.column width="50%"}

![](https://www.geni.org/globalenergy/library/national_energy_grid/united-states-of-america/graphics/UnitedStatesPowerGrid.jpg)

:::
::::

---

Good LLM questions for Starter Assignment:

- [https://github.com/sk-classroom/starter-amahury/blob/main/assignment/quiz.toml](https://github.com/sk-classroom/starter-amahury/blob/main/assignment/quiz.toml)
- [https://github.com/sk-classroom/starter-nedachocolate63/blob/main/assignment/quiz.toml](https://github.com/sk-classroom/starter-nedachocolate63/blob/main/assignment/quiz.toml)

---

## Clustering Coefficient (3)

[Global clustering coefficient]{.red-text} focuses on the total number of triangles in the network.

$$
C = \frac{3 \times \text{number of triangles}}{\text{number of connected triplets}} = \frac{3 \times \text{number of triangles}}{\sum_{i} k_i(k_i-1)/2}
$$

where $k_i$ is the degree of node $i$.

::: {.columns}

::: {.column width="55%"}

[Connected triplets]{.blue-text} = Three nodes joined by at least two edges.
[When counting, we distinguish the triplets by the node that is centered]{.red-text}.
A triangle counts as three triplets. A node with degree $k$ has $k(k-1)/2$ triplets.

:::

::: {.column width="45%"}



```{dot}
//| fig-width: 5
//| fig-height: 2.5
//| fig-cap: "Closed triplet (left) and open triplet (right)"
//| fig-align: center
graph G {
  layout=neato;
  fontsize=16;

  node [fontsize=14];

  subgraph cluster_0 {
    label="Closed Triplet";
    fontsize=16;
    style=filled;
    color=lightgrey;
    node [shape=circle, fillcolor="#f5cbcc", style="filled,bold", penwidth=2];
    A1 [pos="-1.5,0!" shape=circle];
    B1 [pos="-2.5,-1!" shape=circle];
    C1 [pos="-0.5,-1!" shape=circle];
    A1 -- B1;
    B1 -- C1;
    C1 -- A1;
  }

  subgraph cluster_1 {
    label="Open Triplet";
    fontsize=16;
    style=filled;
    color=lightgrey;
    node [shape=circle, fillcolor="#d0e2f3", style="filled,bold", penwidth=2];
    A2 [pos="1.5,0!" ];
    B2 [pos="0.5,-1!" ];
    C2 [pos="2.5,-1!" ];
    A2 -- B2;
    B2 -- C2;
  }
}
```

:::
:::

---

Quiz:

- Compute the global clustering coefficient and the average path length of the following network.

```{dot}
//| fig-width: 3
//| fig-height: 2.5
//| fig-align: center
graph G {
  layout=circo
  A [shape=circle, fillcolor="#f5cbcc", style="filled,bold", penwidth=2, pos="0,0!"];
  B [shape=circle];
  C [shape=circle];
  D [shape=circle];
  E [shape=circle];
  F [shape=circle];

  A -- B;
  A -- C;
  A -- D;
  A -- E;
  A -- F;
  B -- F;
  C -- E;
}
```

- Let's define the ratio of the clustering coefficient to the average path length as the small-worldness index. What is the problem with this definition?

---

## Learning Objectives

- **MST**: Minimum spanning trees and network design
- **Robustness**: Random failures vs. targeted attacks
- **Theory**: Percolation theory and connectivity
- **Design**: Robust networks balancing efficiency and resilience

**Keywords**: MST, Kruskal's algorithm, Prim's algorithm, percolation, R-index, robustness paradox

---


::: {.columns}

::: {.column width="70%"}

**Quiz**:
Prove the following Molly-Reed criterion:
A random network (with a given degree distribution) has a giant component if and only if

$$
\frac{\langle k^2 \rangle}{\langle k \rangle} > 2,
$$

where $\langle k \rangle$ and $\langle k^2 \rangle$ are the average degree and the average squared degree, respectively.
:::

::: {.column width="30%"}


```{dot}
//| fig-width: 3
//| fig-height: 3
//| fig-align: center
graph G {
    node [shape=circle]

    10 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    20 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    21 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    30 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    31 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    32 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    40 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    41 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    42 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    43 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]

    1 -- 10 [penwidth=3, color="#1a43bf", fontsize=20]

    // MST edges (highlighted)
    10 -- 20 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 21 [penwidth=0, color="#ffffffff", fontsize=20]

    10 -- 30 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 31 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 32 [penwidth=0, color="#ffffffff", fontsize=20]


    10 -- 40 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 41 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 42 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 43 [penwidth=0, color="#ffffffff", fontsize=20]

    // ----
    20 -- 2 [penwidth=3, color="#1a43bf", fontsize=20]
    21 -- 2 [penwidth=3, color="#1a43bf", fontsize=20]


    30 -- 3 [penwidth=3, color="#1a43bf", fontsize=20]
    31 -- 3 [penwidth=3, color="#1a43bf", fontsize=20]
    32 -- 3 [penwidth=3, color="#1a43bf", fontsize=20]


    40 -- 4 [penwidth=3, color="#1a43bf", fontsize=20]
    41 -- 4 [penwidth=3, color="#1a43bf", fontsize=20]
    42 -- 4 [penwidth=3, color="#1a43bf", fontsize=20]
    43 -- 4 [penwidth=3, color="#1a43bf", fontsize=20]
}
```



:::
:::


**Hint**:
1. Think about how many friends a node's friends should have on average to be a part of the giant component.
2. Then, identify the probability to handshake with a node with degree $k$ given degree distribution $p(k)$.
3. Integrate over the distribution to get the average degree of a friend

---

[Pen & Paper Exercise](./pen-and-paper/exercise.pdf)

---

# Part I: Minimum Spanning Tree

---

## Post-WWI Czechoslovakia Challenge

:::: {.columns}

::: {.column width="50%"}


- Connect all towns with electricity
- Limited resources for infrastructure
- Minimize cable length
- First systematic solution by Otakar Bor≈Øvka (1899-1995)


:::

::: {.column width="50%"}

![](https://www.railpass.com/sites/default/files/2016-07/CZECH.02.jpg)


:::
::::

**‚ùì Question**: How would you connect all towns with the minimum total cable length?

*Take 30 seconds to think about your approach...*

---

## üí° Key Insight

**Key Insight**: We need a **tree** that connects all nodes with minimum total weight.


::: {.columns}

::: {.column width="60%"}

**Why a tree?**

- No redundant connections (cycles)
- Every node connected exactly once
- Minimum possible edges for full connectivity

:::

::: {.column width="40%"}

```{dot}
//| fig-width: 3
//| fig-height: 3
//| fig-align: center
//| fig-cap: "Red edges form a tree. Dashed edges are redundant."
graph G {
    rankdir=LR
    layout=fdp
    node [shape=circle]

    // MST edges (highlighted)
    1 -- 2 [penwidth=3, color=red]
    3 -- 6 [penwidth=3, color=red]
    4 -- 5 [penwidth=3, color=red]
    2 -- 6 [penwidth=3, color=red]
    6 -- 5 [penwidth=3, color=red]

    // Non-MST edges (normal)
    1 -- 6 [style=dashed]
    3 -- 4 [style=dashed]
  }
```


:::
::::

---

## Minimum Spanning Tree (MST)


::: {.columns}

::: {.column width="60%"}
A **minimum spanning tree (MST)** of a weighted network is a tree that:

- **Spans** all nodes (connects every location)
- Is a **tree** (no cycles, no redundant loops)
- Has **minimum total weight** among all spanning trees

:::

::: {.column width="40%"}

```{dot}
//| fig-width: 3
//| fig-height: 2.5
//| fig-align: center
graph G {
    rankdir=LR
    layout=circo
    node [shape=circle]

    // MST edges (highlighted)
    1 -- 2 [label="1", color=red, penwidth=3]
    3 -- 6 [label="2", color=red, penwidth=3]
    4 -- 5 [label="6", color=red, penwidth=3]
    2 -- 6 [label="9", color=red, penwidth=3]
    3 -- 4 [label="11", color=red, penwidth=3]

    // Non-MST edges (normal)
    1 -- 6 [label="14"]
    2 -- 3 [label="10"]
    5 -- 6 [label="9"]
}
```


:::
::::


## ü§î Algorithm Design Question

**‚ùì Question**: Given that we want the minimum spanning tree, what strategy would you use to build it?

*Think about: Should we start with the cheapest connections? What if adding a cheap connection creates a loop?*

---

## üí° The Answer: Kruskal's Algorithm

**Intuition**: "Choose cheapest option, avoid wasteful loops"

::: {.columns}

::: {.column width="60%"}

1. Sort edges by weight (cheapest first)
2. Add edges in order
3. Skip if creates cycle
4. Continue until all connected

**Global Perspective**: Considers all connections simultaneously

:::

::: {.column width="40%"}

```{dot}
//| fig-width: 3
//| fig-height: 2.5
//| fig-align: center
graph G {
    rankdir=LR
    layout=circo
    node [shape=circle]

    // MST edges (highlighted)
    1 -- 2 [label="1", penwidth=3, color=red, fontsize=20]
    3 -- 6 [label="2", penwidth=3, color=red, fontsize=20]
    4 -- 5 [label="6", penwidth=3, color=red, fontsize=20]
    2 -- 6 [label="9", penwidth=3, color=red, fontsize=20]
    3 -- 4 [label="11", penwidth=3, color=red, fontsize=20]

    // Non-MST edges (normal)
    1 -- 6 [label="14", fontsize=20]
    2 -- 3 [label="10", fontsize=20]
    5 -- 6 [label="9", fontsize=20]
}
```

:::
::::

---

## üí° Prim's Algorithm

**Intuition**: "Organic growth from starting point"

::: {.columns}

::: {.column width="60%"}

1. Start from any node (power plant)
2. Find cheapest connection to an unconnected node
3. Add edge, mark node as connected
4. Repeat until all connected

**Local Perspective**: Builds incrementally from existing network

:::

::: {.column width="40%"}

```{dot}
//| fig-width: 3
//| fig-height: 2.5
//| fig-align: center
graph G {
    rankdir=LR
    layout=circo
    node [shape=circle]

    // MST edges (highlighted)
    1 -- 2 [label="1", penwidth=3, color=red, fontsize=20]
    3 -- 6 [label="2", penwidth=3, color=red, fontsize=20]
    4 -- 5 [label="6", penwidth=3, color=red, fontsize=20]
    2 -- 6 [label="9", penwidth=3, color=red, fontsize=20]
    3 -- 4 [label="11", penwidth=3, color=red, fontsize=20]

    // Non-MST edges (normal)
    1 -- 6 [label="14", fontsize=20]
    2 -- 3 [label="10", fontsize=20]
    5 -- 6 [label="9", fontsize=20]
}
```

:::
::::

## Kruskal vs. Prim

[A demo in lecture notes](https://skojaku.github.io/adv-net-sci/m03-robustness/01-concepts.html)

**üí¨ Discussion**: When do they find the same MST? When not?

# Part II: Network Robustness


## ü§î The Vulnerability Problem

:::: {.columns}

::: {.column width="50%"}

What happens if a single node in our MST fails?

*Think about: How many towns would lose power? What does this mean for real infrastructure?*

Cost efficiency ‚â† Robustness


:::

::: {.column width="50%"}

```{dot}
//| fig-width: 3
//| fig-height: 2.5
//| fig-align: center
graph G {
    rankdir=LR
    layout=circo
    node [shape=circle]

    // MST edges (highlighted)
    1 -- 2 [label="1", penwidth=3, color=red, fontsize=20]
    3 -- 6 [label="2", penwidth=3, color=red, fontsize=20]
    4 -- 5 [label="6", penwidth=3, color=red, fontsize=20]
    2 -- 6 [label="9", penwidth=3, color=red, fontsize=20]
    3 -- 4 [label="11", penwidth=3, color=red, fontsize=20]

    // Non-MST edges (normal)
    1 -- 6 [label="14", fontsize=20]
    2 -- 3 [label="10", fontsize=20]
    5 -- 6 [label="9", fontsize=20]
}
```
:::
::::

**üí¨ Discussion**: How would you modify the network to make it more robust? What are the trade-offs between cost and reliability?

---

## Measuring Network Connectivity

$$\text{Connectivity} = \frac{\text{Size of largest component after removal}}{\text{Original network size}}$$


![](https://skojaku.github.io/adv-net-sci/figs/single-node-failure.jpg){fig-align="center"}


---

**Robustness Profile**: Connectivity vs. fraction of nodes removed


![](https://skojaku.github.io/adv-net-sci/figs/robustness-profile.jpg){fig-align="center"}

**R-index**: Area under robustness curve
$$R = \frac{1}{N} \sum_{k=1}^{N-1} y_k$$

---

## ü§î Attack Strategies

**Random Failures**:

- Unpredictable events
- Earthquakes, equipment malfunctions
- Technical problems, random server crashes
- Characterized by equal probability of failure for all nodes

**Targeted Attacks**:

- Strategic node removal by adversaries
- Target busiest airports to disrupt air travel
- Characterized by removing highest-degree nodes, then next highest

---

## Game Time!

[Interactive game](https://skojaku.github.io/adv-net-sci/assets/vis/network-robustness.html)

- Think about a structure that is robust to random failures/targeted attacks/both

- Why might the same network structure respond so differently to these two scenarios? What does this tell us about network design?

# Part III: Theoretical Framework

## Percolation Theory


::: {.columns}

::: {.column width="50%"}

- Suppose puddles are scattered on the ground.
- As rain falls, puddles begin to merge with nearby puddles.
- At first, most puddles are isolated; as more rain falls, clusters form, and eventually a giant puddle spans a large part of the area.
:::

::: {.column width="50%"}

![](https://jamesmccaffrey.wordpress.com/wp-content/uploads/2021/07/percolation.jpg)

:::
:::

**Percolation theory** studies how local connections (like merging puddles) lead to sudden global connectivity.

[Lecture notes for demonstration](https://skojaku.github.io/adv-net-sci/m03-robustness/01-concepts.html)

---

## Phase Transition

**Critical Point ($p_c$)**: Threshold where giant component emerges/disappears

**2D Lattice Example**: $p_c \approx 0.593$

[Lecture notes for demonstration](https://skojaku.github.io/adv-net-sci/m03-robustness/01-concepts.html)

The sharp transition around $p_c$ demonstrates a **phase transition**, i.e., a sudden change from a disconnected to connected state as we cross the critical threshold.

Network Robustness - Where is the critical point?


---

## ü§î Let's Think Like Network Scientists


Let's learn how to find the critical point $p_c \approx 0.593$

::: {.columns}

::: {.column width="50%"}
Imagine you're a node in a network. For you to be a part of the largest connected component, what do you & your friends need ü§î?

- You need **friends** (connections)
- What else do your friends need?

:::

::: {.column width="50%"}

![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgK7a_hh-YeNoQIsQUnW8A2tnO7Us97s6XrvVTOpSWzKuixhdj8sRMK3drH3c-p94r9RRqMZNGaT7-Xat-zQwt4lmh0k1gdRDqTbtlYGqxOG4JzuoCUEzkF19eRWDmPxYBa9cAe-lLV0vaD/s500/world_people_circle.png)

:::
:::

## üîó Friends of Friends

::: {.columns}

::: {.column width="50%"}

::: {.incremental}
- Each friend needs at least **2 connections**
- One connection: **to you**
- Another connection: **to someone else** (to reach the rest of the network)
:::

:::

::: {.column width="50%"}

![](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgK7a_hh-YeNoQIsQUnW8A2tnO7Us97s6XrvVTOpSWzKuixhdj8sRMK3drH3c-p94r9RRqMZNGaT7-Xat-zQwt4lmh0k1gdRDqTbtlYGqxOG4JzuoCUEzkF19eRWDmPxYBa9cAe-lLV0vaD/s500/world_people_circle.png)

:::
:::

# Your friends need at least 2 friends (on average) for you to be a part of the giant component!

$$
\text{Average \# of friends that friends have} \geq 2
$$

---

Let's formalize this insight.

$$
\text{Average \# of friends that friends have} \geq 2
$$


::: {.columns}

::: {.column width="50%"}


1. Suppose you are node 1 with one hand
2. Other nodes have $k$ hands with probability $p(k)$
3. When you handshake with a randomly picked **hand** (not node), how many hands do your friends would have on average ü§î?

:::

::: {.column width="50%"}

```{dot}
//| fig-width: 5
//| fig-height: 5
//| fig-align: center
graph G {
    node [shape=circle]

    10 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    20 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    21 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    30 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    31 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    32 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    40 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    41 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    42 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]
    43 [color=black, label="", shape="square", width=0.1, fill="black", style="filled"]

    1 -- 10 [penwidth=3, color="#1a43bf", fontsize=20]

    // MST edges (highlighted)
    10 -- 20 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 21 [penwidth=0, color="#ffffffff", fontsize=20]

    10 -- 30 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 31 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 32 [penwidth=0, color="#ffffffff", fontsize=20]


    10 -- 40 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 41 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 42 [penwidth=0, color="#ffffffff", fontsize=20]
    10 -- 43 [penwidth=0, color="#ffffffff", fontsize=20]

    // ----
    20 -- 2 [penwidth=3, color="#1a43bf", fontsize=20]
    21 -- 2 [penwidth=3, color="#1a43bf", fontsize=20]


    30 -- 3 [penwidth=3, color="#1a43bf", fontsize=20]
    31 -- 3 [penwidth=3, color="#1a43bf", fontsize=20]
    32 -- 3 [penwidth=3, color="#1a43bf", fontsize=20]


    40 -- 4 [penwidth=3, color="#1a43bf", fontsize=20]
    41 -- 4 [penwidth=3, color="#1a43bf", fontsize=20]
    42 -- 4 [penwidth=3, color="#1a43bf", fontsize=20]
    43 -- 4 [penwidth=3, color="#1a43bf", fontsize=20]
}
```

:::
:::


---

Suppose $p(k)$ is the fraction of nodes with $k$ hands. Altogether, nodes with $k$ hands contribute $k p(k)$ hands to the network.

If I randomly pick a hand, I would handshake with a node with $k$ hands with probability proportional to $k p(k)$. That is

$$
q(k) = \frac{k p(k)}{\sum_{k=1}^{\infty} k p(k)} = \frac{k}{\langle k \rangle } p(k),
$$

where $\langle k \rangle = \sum_{k=1}^{\infty} k p(k)$ is the average degree. Now, the average number of hands that my friends would have on average is

$$
\langle k \rangle_{q(k)} = \sum_{k=1}^{\infty} k q(k) = \sum_{k=1}^{\infty} k^2 / \langle k \rangle p(k) = \frac{\langle k^2 \rangle}{\langle k \rangle}.
$$

---

## üéØ The Molloy-Reed Criterion
You just discovered the **Molloy-Reed Criterion**!
$$\kappa = \frac{\langle k^2 \rangle}{\langle k \rangle} > 2$$

When is the $\kappa$ smallest ü§î? What is the implication in terms of the robust network structure against random failures?

*Take 2 mins to think about it...*

::: {.incremental}
- **High Œ∫**: Hub-dominated networks (some nodes have many friends)
- **Low Œ∫**: Degree homogeneous networks (everyone has similar friends)
- **Implication**: Hubs make networks more robust!
:::

---

## üßÆ From Œ∫ to Critical Fraction
Now let's figure out: **What fraction of nodes can we remove before the network fragments?**

::: {.columns}

::: {.column width="50%"}

Hint: After removing a fraction $f$ of nodes randomly, what happens to the number of friends a friend would have?

And when does the Molloy-Reed criterion break?

*Take 3 mins to think about it.*

:::

::: {.column width="50%"}


```{dot}
//| fig-width: 5
//| fig-height: 5
//| fig-align: center
graph G {
    node [shape=circle, style="filled",width=1.0, penwidth=2, fillcolor=white]

    1 [label = "You", fillcolor = "#d0e2f3"]
    2 [label = "Friend", fillcolor = "#f5cbcc"]
    21 [label="Survived"]
    22 [label="Survived"]
    23 [style="dashed", label="Removed"]


    1 -- 2
    2 -- 21
    2 -- 22
    2 -- 23 [style="dashed"]
}
```

:::
:::

---


::: {.incremental}
- After removing fraction $f$, my friend who initially has---$\kappa$ friends on average---have $(1-f)(\kappa -1)$ friends on average.
- It's $\kappa-1$ not $\kappa$ because one of the friends is me.
- Thus, the network breaks when $(1-f)(\kappa - 1) = 1$
- Solving for $f$, we get $$f_c = 1 - \frac{1}{\kappa - 1}$$
:::

## ü§î Case Study: Degree-Homogeneous Networks

Let's consider a degree-homogeneous network, where
the degree distribution is Poisson with mean $\lambda$, i.e.,

$$
k \sim \mathrm{Poisson}(\lambda)
$$

What is the critical point $f_c$?

Hint:

- $f_c = 1 - \frac{1}{\kappa - 1}$, $\kappa = \frac{\langle k^2 \rangle}{\langle k \rangle}$
- The mean and variance of the Poisson distribution are identical.

---

For a Poisson distribution with mean $\lambda$:

- The first moment (mean degree) is $\langle k \rangle = \lambda$
- The second moment is $\langle k^2 \rangle = \lambda^2 + \lambda$

Now, we can calculate $\kappa$:

$$
\kappa = \frac{\langle k^2 \rangle}{\langle k \rangle} = \frac{\lambda^2 + \lambda}{\lambda} = \lambda + 1
$$

Finally, we can find the critical fraction $f_c$:
$$
f_c = 1 - \frac{1}{\kappa - 1} = 1 - \frac{1}{(\lambda + 1) - 1} = 1 - \frac{1}{\lambda} $$

**Key Insight**: Higher average degree makes the network more robust.

---

## ü§î Case Study: Degree-heterogenous networks

::: {.columns}

::: {.column width="50%"}

**‚ùì Question**: What happens to network robustness when we have a few very highly connected nodes (hubs) and many poorly connected nodes?

*Think about: How would random failures affect this type of network? What about targeted attacks?*

:::

::: {.column width="50%"}

![](https://live.staticflickr.com/8473/8425835703_dd0f952b5b_b.jpg)

:::
:::

## üí° Robustness of scale-free networks

::: {.columns}


::: {.column width="50%"}

Let's consider a scale-free network with the degree distribution:

$$P(k) \sim k^{-\gamma}$$

Infinite variance for $\gamma < 3$, undefined mean for $\gamma \leq 2$.

Most real-world networks do not have finite variance!

What does it mean in terms of the robustness of the network?

:::

::: {.column width="50%"}

![](https://live.staticflickr.com/8473/8425835703_dd0f952b5b_b.jpg)


:::
:::

---

::: {.columns}


::: {.column width="60%"}

When the network is infinite,

$f_c \rightarrow 1$ when $2 < \gamma < 3$.

When the network is finite,

$$f_c = \begin{cases}
1 - \dfrac{1}{\frac{\gamma-2}{3-\gamma} k_{\text{min}} ^{\gamma-2} k_{\text{max}}^{3-\gamma} -1} & \text{if } 2 < \gamma < 3 \\
1 - \dfrac{1}{\frac{\gamma-2}{\gamma-3} k_{\text{min}} - 1} & \text{if } \gamma > 3 \\
\end{cases}$$
$
where $k_{\text{min}}$ and $k_{\text{max}}$ are the minimum and maximum degree.
([Visualization](https://skojaku.github.io/adv-net-sci/m03-robustness/01-concepts.html))


:::

::: {.column width="40%"}

![](https://live.staticflickr.com/8473/8425835703_dd0f952b5b_b.jpg)




:::
:::


**Key Insight**: Scale-free networks are remarkably robust to random failures.



## ü§î Questions

::: {.incremental}
- **‚ùì Question #1**: If scale-free networks are so robust to random failures, what's their weakness?
  - *Scale-free networks are fragile under targeted attacks.*
- **‚ùì Question #2**: What type of attack is the most effective and why?
  - *Removing the highest degree node and then the second highest degree node, and so on, is the most effective.*
  - *...because the critical fraction depends on $k_{\text{max}}$.*
:::


## Critical point $f_c$ for targeted attacks

::: {.columns}

::: {.column width="60%"}

A node removal changes the degree distribution from $P(k)$ to $P'(k)$. Specifically,

1. A node with degree $k$ is removed from $P(k)$, and
2. its neighbors lose 1 degree.


:::

::: {.column width="40%"}

```{dot}
//| fig-width: 3.5
//| fig-height: 3.5
//| fig-align: center
graph G {
    layout=fdp

    node [shape=circle, style="filled", width=0.8, penwidth=2, fillcolor=white, fontsize=12]
    edge [penwidth=2, color="#666666"]


    1 [label="Removed", style="dashed", fillcolor="#ffeeee"]

    // Surviving nodes with reduced degrees
    2 [label = "A", fillcolor="#f5cbcc"]
    3 [label = "B", fillcolor="#f5cbcc"]
    4 [label = "C", fillcolor="#f5cbcc"]
    5 [label = "E", fillcolor="#d0e2f3"]
    6 [label = "F", fillcolor="#f5cbcc"]
    7 [label = "G", fillcolor="#d0e2f3"]

    // Ghost edges to removed node
    1 -- 2 [style="dashed", color="#cccccc"]
    1 -- 3 [style="dashed", color="#cccccc"]
    1 -- 4 [style="dashed", color="#cccccc"]
    1 -- 6 [style="dashed", color="#cccccc"]

    // Remaining edges
    2 -- 3
    2 -- 5
    3 -- 4
    3 -- 6
    4 -- 7
    5 -- 6
    6 -- 7
}
```

:::
:::

We ask: when does $P'(k)$ lose the giant component as nodes are removed?
This gives:

$$f_c^{\frac{2-\gamma}{1-\gamma}} = \frac{2 + 2^{-\gamma}}{3-\gamma} k_{\min} \left(f_c^{\frac{3-\gamma}{1-\gamma}} - 1\right)$$

---

::: {.columns}

::: {.column width="40%"}

- $f_c$ increases as $\gamma$ increases, which is in contrast to the random failures case.

- $f_c$ for the random and targeted attacks converge to the same value as $\gamma \rightarrow \infty$.

:::

::: {.column width="60%"}

$$f_c^{\frac{2-\gamma}{1-\gamma}} = \frac{2 + 2^{-\gamma}}{3-\gamma} k_{\min} \left(f_c^{\frac{3-\gamma}{1-\gamma}} - 1\right)$$

![](https://networksciencebook.com/images/ch-08/figure-8-12.jpg)

:::
:::

---


## ü§î Design Challenge

**‚ùì Question**: Given what we've learned about network vulnerabilities, how would you design a robust network?

*Consider: What principles would you use? How would you balance cost, efficiency, and security?*

Create a network with [Interactive game](https://skojaku.github.io/adv-net-sci/assets/vis/network-robustness.html)

---

# Let's code!

---

List of all nodes
```python
import igraph
import numpy as np

g = igraph.Graph.Famous("Zachary")
g.vs.indices
```

Remove a node
```python
node_idx = 0
g.delete_vertices(node_idx)
```

Component size
```python
components = g.connected_components()
components.sizes() # Sizes of all components
np.max(components.sizes()) # Size of the largest component
```

Misc:
```python
np.max(a) # Maximum value of a
np.random.choice(a) # Random choice from a
np.argmax(a) # Index of the maximum value of a
```



