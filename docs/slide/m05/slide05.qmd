---
format:
  revealjs:
    slide-number: true
    chalkboard:
      buttons: true
    preview-links: auto
    css: css/style.css
  html:
    code-fold: true
    code-tools: true
highlight-style: oblivion
execute:
    enabled: true
    echo: false
---


## Check list

- [ ] Microphone turned on
- [ ] Zoom room open
- [ ] Recording on
- [ ] Mouse cursor visible
- [ ] Sound Volume on

---

::: {.columns}
::: {.column width="60%"}
Q1: The friendship paradox states that, on average, your friends have more friends than you do. Prove this statement.
Denote by $p(k)$ the degree distribution and $\langle \cdot \rangle$ the average.

Q2: A Twitter user aims to estimate the proportion of spam or fake accounts on the platform and suggests a plan. Discuss the pros and cons of this plan.


:::

::: {.column width="40%"}
![](twitter.png)
:::
:::

# Good LLM quiz questions ü§ñ

---

**By Urvi** üéâ

**Question:**
Can a network with clustering coefficient = 1 be small-world?

**Expected Answer:**
Student's Answer: No, that‚Äôs just a complete graph (shortest path length = 1,¬†but¬†trivial).

**LLM's Answer:**
LLM's Answer: Yes, a network with a clustering coefficient of 1 can be a small-world network. The Watts-Strogatz model demonstrates this precisely.  A clustering coefficient of 1 indicates that every node is part of a fully connected ‚Äúclique‚Äù with its immediate neighbors ...

---

**By Sarah** üéâ

**Question:**
What can we conclude about the small world-ness of a network where it's average clustering coefficient and global clustering coefficient are both equal to 1?


**Expected Answer:**
We conclude it is not a small world network since having both coefficients equal to 1 signifies a fully connected network which therefore cannot also be small-world.

**LLM's Answer:**
The small-world property of a network, characterized by both high clustering and short average path lengths, is concluded when both the average clustering coefficient and the global clustering coefficient are equal to 1. This signifies that every node in the network is highly connected to its immediate neighbors, forming dense local communities (high clustering). Simultaneously, it indicates that, on average, any two nodes in the network are only a few steps away from each other (short average path length).

---

**By Amahury** üéâ

**Question:**
True or False (justify briefly): The simple cycle graph C_N with N ‚â• 5 is small-world (œÉ > 1) under the Humphries‚ÄìGurney definition when using C as transitivity and an Erd≈ës‚ÄìR√©nyi baseline with the same N and M.

**Expected Answer:**
Student's Answer: False. C_N has no triangles, so C = 0. With an ER baseline (same N, M) we have C_rand > 0 and L/L_rand is finite, hence œÉ = (0/C_rand)/(L/L_rand) = 0 < 1.

**LLM's Answer:**
The statement "The simple cycle graph C_N with N ‚â• 5 is small-world (œÉ > 1) under the Humphries‚ÄìGurney definition when using C as transitivity and an Erd≈ës‚ÄìR√©nyi baseline with the same N and M" is **true**.



# Module 5: Clustering üß©

---

What we will learn in this module:

- What is community structure in networks? üåê
- How to operationalize community structure? üî¨
- How to find communities in networks? üîç
- Limitations of community detection üöß

**Keywords**: community detection, assortativity, modularity, resolution limit, rugged landscape, random graph, label switching algorithm, Louvain algorithm, stochastic block model, the configuration model.


## What is Community? üê¶

::: {.columns}
::: {.column width="60%"}

- "Birds of a feather flock together"
- In networks, communities are groups of nodes with similar connection patterns.
- They can reflect:
  - **Homophily**: similar nodes connect.
  - **Functional groups**: nodes collaborating for a purpose.
  - **Hierarchical structure**: communities within communities.
:::

::: {.column width="40%"}
![](https://t4.ftcdn.net/jpg/08/10/89/17/360_F_810891701_xy4NsqgdqllMfKDfV6V27ycrw8FLFqrw.jpg){width="70%" fig-align="center"}
![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/f4/Network_Community_Structure.svg/220px-Network_Community_Structure.svg.png){width="70%" fig-align="center"}
:::
:::

## How to Find Communities?

1. **Pattern matching approach**
    - Define a community pattern and find it.

2. **Optimization approach**
    - Maximize a quality function of a partition.

3. **Generative model**
    - Fit a generative model to the network.

# Pattern Matching

## Pattern Matching üß©: Cliques

- **Clique**: a group of nodes where everyone is connected to everyone else.
- The strictest definition of a community.
- Often too rigid for real-world networks.

![Image of cliques](https://pythonhosted.org/trustedanalytics/R_images/k-clique_201508281155.png){width="700"}


## Clique Percolation (Palla 2005 Nature)

::: {.columns}
::: {.column width="60%"}
- **Idea**: Communities are formed by overlapping cliques
- Start with all k-cliques in the network
- Two k-cliques are connected if they share k-1 nodes
- Communities are connected components in this "clique graph"

:::
::: {.column width="40%"}
![](https://www.researchgate.net/publication/1903620/figure/fig32/AS:667032957747213@1536044458826/Clique-Percolation-Method-The-example-shows-communities-spanned-by-adjacent-4-cliques.png){width="70%" fig-align="center"}
:::
:::

**Advantages:**

Allows overlapping communities, based on strong local cohesion, and parameter $k$ controls the number of communities.


## Issue of cliques

![](https://pythonhosted.org/trustedanalytics/R_images/k-clique_201508281155.png){width="700" fig-align="center"}

Real-world groups are rarely perfect cliques. We relax the definition along three dimensions:

1.  **Degree**: Not every node needs to be fully connected.
2.  **Density**: The group doesn't need all possible edges.
3.  **Distance**: Members can be a few steps away from each other.

## Pen and Paper Exercises ‚úçÔ∏è

- [Exercise 1: What is a community?](https://skojaku.github.io/adv-net-sci/m05-clustering/pen-and-paper/exercise.pdf) üö¢

## Degree Relaxation: k-plex and k-core

::: {.columns}
::: {.column width="50%"}
- **k-plex**: each node can miss connections to at most $k$ others in the group.
- **k-core**: each node has at least $k$ connections within the group.
:::
::: {.column width="50%"}
``````{dot}
//| fig-width: 6
//| fig-height: 3
//| fig-align: center
graph G {
    layout=fdp;
    node [shape=circle, style=filled, fontsize=20, width=0.6];
    edge [len=1.5];
    subgraph cluster_dense {
        label=" 2-plex, 2-core";
        fontsize=20;
        peripheries=0;
        a [pos="0.5,2.5!", fillcolor="#45b7d1"];
        b [pos="1.5,3!", fillcolor="#45b7d1"];
        c [pos="2,2!", fillcolor="#45b7d1"];
        d [pos="1.5,1!", fillcolor="#45b7d1"];
        e [pos="0.5,1.5!", fillcolor="#45b7d1"];
        a -- b; a -- e; b -- c; b -- e; c -- d; c -- e; d -- e;
    }
    subgraph cluster_not_dense {
        label="3-plex, 1-core";
        fontsize=20;
        peripheries=0;
        f [pos="5.5,2.5!", fillcolor="#ff9999"];
        g [pos="6.5,3!", fillcolor="#ff9999"];
        h [pos="7,2!", fillcolor="#ff9999"];
        i [pos="6.5,1!", fillcolor="#ff9999"];
        j [pos="5.5,1.5!", fillcolor="#ff9999"];
        f -- g; g -- h; i -- j; j -- f;
    }
}
``````
:::
:::

## Density Relaxation: $\rho$-dense subgraph

::: {.columns}
::: {.column width="50%"}
- A **$\rho$-dense subgraph** has at least a fraction $\rho$ of all possible internal edges.
- Useful for communities that are highly, but not perfectly, interconnected.
:::
::: {.column width="50%"}
``````{dot}
//| fig-width: 6
//| fig-height: 3
//| fig-align: center
graph G {
    layout=fdp;
    node [shape=circle, style=filled, fontsize=20, width=0.6];
    edge [len=1.5];
    subgraph cluster_dense {
        label="0.7-dense";
        fontsize=20;
        peripheries=0;
        a [pos="0.5,2.5!", fillcolor="#45b7d1"];
        b [pos="1.5,3!", fillcolor="#45b7d1"];
        c [pos="2,2!", fillcolor="#45b7d1"];
        d [pos="1.5,1!", fillcolor="#45b7d1"];
        e [pos="0.5,1.5!", fillcolor="#45b7d1"];
        a -- b; a -- e; b -- c; b -- e; c -- d; c -- e; d -- e;
    }
    subgraph cluster_not_dense {
        label="also 0.7-dense";
        fontsize=20;
        peripheries=0;
        f [pos="5.5,2.5!", fillcolor="#ff9999"];
        g [pos="6.5,3!", fillcolor="#ff9999"];
        h [pos="7,2!", fillcolor="#ff9999"];
        i [pos="6.5,1!", fillcolor="#ff9999"];
        j [pos="5.5,1.5!", fillcolor="#ff9999"];
        f -- g; g -- h; i -- j; j -- f; f--h; j--h; j--g;
    }
}
``````
:::
:::

## Distance Relaxation: n-clique, n-clan, n-club

::: {.columns}
::: {.column width="45%"}
- **n-clique**: every pair of nodes is within $n$ steps of each other.
- **n-clan**: every pair of nodes is within $n$ steps of each other within the group.
- Captures communities knit by short, internal paths, not just direct ties.
:::
::: {.column width="55%"}
``````{dot}
//| fig-width: 6
//| fig-height: 3
//| fig-align: center
graph G {
    layout=fdp;
    node [shape=circle, style=filled, fontsize=20, width=0.4, fillcolor=black];
    edge [len=1.2];
    subgraph cluster_clique {
        style=dashed;
        fontsize=16;
        peripheries=0;
        subgraph cluster_clan {
            label="3-clan, 2-clique";
            style=dashed;
            fontsize=20;
            peripheries=1;
            a [pos="2,2!" fillcolor="#45b7d1"];
            b [pos="4,2!" fillcolor="#45b7d1"];
            c [pos="4,0.5!" fillcolor="#45b7d1"];
            d [pos="2,0.5!" fillcolor="#45b7d1"];
            a -- b; c -- d; d -- a;
        }
        e [pos="0.5,1.25!" fillcolor="#afafaf"];
        f [pos="5.5,1.25!" fillcolor="#afafaf"];
        e -- a; e -- d; f -- b; f -- c;
    }
}
``````
:::
:::

## Hybrid Approaches

Combine dimensions to capture tightly-knit community structures.


::: {.columns}
::: {.column width="40%"}

- **k-truss**: every edge must be part of at least $k-2$ triangles. Emphasizes triadic closure.
- **$\rho$-dense core**: balances high internal density with sparse external connections.

:::
::: {.column width="60%"}

![Pseudo-clique patterns](https://ars.els-cdn.com/content/image/1-s2.0-S0378873315000520-gr1.jpg){width="600"}

:::
:::


# Optimization Approach üîç


## Overview: Optimization Approach

::: {.columns}
::: {.column width="50%"}
- Define a quality function for a partition of nodes into communities.
- Search for the partition that maximizes (or minimizes) this function.
- Examples:
    - Graph Cut
    - Balanced Cut
    - Modularity
:::
::: {.column width="50%"}
![](https://www.science.org/cms/10.1126/sciadv.1602548/asset/c7833b98-fa84-4dd8-a4a1-14bb7ff0fbea/assets/graphic/1602548-f1.jpeg)
:::
:::

## Graph Cut üî™

::: {.columns}
::: {.column width="60%"}

**Goal**: Minimize the number of edges needed to cut to separate the graph into communities.
$$
\text{argmin}_{V_1, V_2} \text{Cut}(V_1, V_2) = \sum_{i \in V_1} \sum_{j \in V_2} A_{ij},
$$

where $V_1$ and $V_2$ are the disjoint sets of nodes (i.e., $V_1 \cap V_2 = \emptyset$ and $V_1 \cup V_2 = V$), and $A_{ij}$ is the adjacency matrix.

:::

::: {.column width="40%"}
![](https://storage.googleapis.com/gweb-research2023-media/images/GraphMinCut2-ConductanceHERO.width-1250.png){width="400" fig-align="center"}
:::
:::

This problem statement is incomplete ü´£. Find out what's missing by playing with the following game.
<a href='https://skojaku.github.io/adv-net-sci/assets/vis/community-detection/index.html?scoreType=graphcut&numCommunities=2&randomness=1&dataFile=two-cliques.json'>Graph Cut Problem üéÆ</a>


## Balanced Cut ‚öñÔ∏è

To avoid trivial cuts, we need to balance community sizes.

- **Ratio Cut**: Penalizes small communities by normalizing by size.
$$
\text{RatioCut}(\{V_c\}) = \sum_c \frac{\text{Cut}(V_c, V \setminus V_c)}{|V_c|}
$$

- **Normalized Cut**: Normalizes by community volume (sum of degrees, i.e., $\text{vol}(V_c) = \sum_{i \in V_c} k_i$).
$$
\text{N-Cut}(\{V_c\}) = \sum_c \frac{\text{Cut}(V_c, V \setminus V_c)}{\text{vol}(V_c)}
$$

We will learn how to solve these problems in Module 08!

## So is the problem solved?

::: {.columns}

::: {.column width="50%"}
- Suppose that we could get a good partition in terms of the objective function.
- But any method has some limitations. What do you think they are ü§î? How would you address that?

::: {.incremental}
- \# of communities need to be specified
- Favor balanced communities
:::


:::

::: {.column width="50%"}

- **Ratio Cut**:
$$
\text{RatioCut}(\{V_c\}) = \sum_c \frac{\text{Cut}(V_c, V \setminus V_c)}{|V_c|}
$$

- **Normalized Cut**.
$$
\text{N-Cut}(\{V_c\}) = \sum_c \frac{\text{Cut}(V_c, V \setminus V_c)}{\text{vol}(V_c)}
$$

:::
:::


## Modularity


**Modularity** is perhaps the most celebrated, yet most controversial, approach to community detection.

Modularity is:

1. able to determine the \# of communities in a network
2. easily optimized
3. an optimal method for planted partition model

**Key idea**: Modularity finds communities that are not just densely connected, but *[denser than random chance]{.red-text}*.


## The Ball and String Game üé®üßµ

::: {.columns}
::: {.column width="40%"}
Imagine colored balls (nodes) and strings (edges).

1.  Count how many strings connect balls of the same color.
2.  Cut all strings, throw the ends in a bag, and draw them randomly.
3.  Modularity = (1) - (2)

:::
::: {.column width="60%"}
![](https://skojaku.github.io/adv-net-sci/figs/modularity.jpg){width="100%"}
:::
:::

## Modularity Formula

$$
Q = \frac{1}{2m} \sum_{i,j} \left[ A_{ij} - P_{ij} \right] \delta(c_i, c_j)
$$

- $A_{ij}$: Adjacency matrix (1 if edge exists, 0 otherwise).
- $P_{ij}$: Probability of an edge between nodes $i$ and $j$ in the null model. For the configuration model, $P_{ij} = \frac{k_i k_j}{2m}$.
- $\delta(c_i, c_j)$: 1 if nodes $i$ and $j$ are in the same community, 0 otherwise.
- $m$: Total number of edges.
- $k_i$: Degree of node $i$.

## Modularity Maximization in Action

Let's play with it!

1.  [Two communities](https://skojaku.github.io/adv-net-sci/assets/vis/community-detection/index.html?scoreType=modularity&numCommunities=2&randomness=1&dataFile=two-cliques.json)
2.  [Four communities](https://skojaku.github.io/adv-net-sci/assets/vis/community-detection/index.html?scoreType=modularity&numCommunities=4&randomness=1&dataFile=two-cliques.json)
3.  [Karate club network](https://skojaku.github.io/adv-net-sci/assets/vis/community-detection/index.html?scoreType=modularity&numCommunities=4&randomness=0.25&dataFile=net_karate.json)
4.  [Resolution Limit Demo](https://skojaku.github.io/adv-net-sci/assets/vis/community-detection/index.html?scoreType=modularity&numCommunities=3&randomness=0.9&dataFile=two-cliques-big-clique.json)
5.  [Random Network Demo](https://skojaku.github.io/adv-net-sci/assets/vis/community-detection/index.html?scoreType=modularity&numCommunities=3&randomness=0.8&dataFile=random-net.json)

## Limitations of Modularity

Modularity is powerful, but not perfect.

1.  **Resolution Limit**: Fails to detect communities smaller than a certain scale, which depends on the size of the whole network. It might merge small, distinct communities.

2.  **Spurious Communities**: Can "find" communities even in random networks where none exist. A high modularity score is not a guarantee of meaningful communities.

3.  **Degeneracy**: Many different partitions can have similarly high modularity scores.

## Modularity on Random Graphs

![](https://skewed.de/lab/posts/modularity-harmful/modularity_fail.png){width="100%" fig-align="center"}

- A high modularity score doesn't always mean we've found meaningful communities.
- Sparse networks tend to have higher modularity scores.
- [We can't compare modularity scores across different networks!]{.red-text}




# Probabilistic Approach: Stochastic Block Model (SBM) üé≤

## Stochastic Block Model (SBM)

Instead of defining what a community *is*, SBM defines how a network is *generated* from communities.

- It's a **generative model** for networks with community structure.
- Nodes are assigned to blocks (communities).

::: {.columns}
::: {.column width="50%"}

- SBM specifies the probability $p_{c_i, c_j}$ of an edge between two nodes in blocks $c_i$ and $c_j$ as:

$$
P(A_{ij} = 1 | c_i, c_j) = p_{c_i, c_j}
$$

:::
::: {.column width="50%"}
![](https://skojaku.github.io/adv-net-sci/m05-clustering/01-concepts_files/figure-html/fig-sbm-adjacency-matrix-output-1.png){width="50%" fig-align="center"}
:::
:::

---

The SBM extends the notion of communities, i.e., a community is a group of nodes that connect to othe nodes in a similar way.

Allow for more broad definitions of communities.

::: {.columns}
::: {.column width="50%"}
   - **Assortative communities**: Densely connected within and sparsely connected between.
   - **Disassortative communities**: Sparsely connected within and densely connected between.
   - **Mixed communities**: Core-periphery structure.
:::
::: {.column width="50%"}
![](https://www.biorxiv.org/content/biorxiv/early/2018/06/25/355016/F1.large.jpg){width="100%" fig-align="center"}
:::
:::

---

::: {.columns}
::: {.column width="60%"}

Given a network, we can infer the most plausible community structure that generated it (if it was generated by SBM) by maximizing the likelihood function, i.e.,

$$
\begin{aligned}
&\text{argmax}_{c_1, \ldots, c_n, \theta} \sum_{i<j} \ell_{ij}(c_i, c_j, \theta), \\
&\ell_{ij} = A_{ij} \log p_{c_i, c_j} +  (1 - A_{ij}) \log (1 - p_{c_i, c_j}),
\end{aligned}
$$

where $c_i$ is the community of node $i$, $\theta$ is the parameters of the SBM, and $p_{c_i, c_j}$ is the probability of an edge between two nodes in blocks $c_i$ and $c_j$.


:::
::: {.column width="40%"}
![](https://media.springernature.com/lw685/springer-static/image/art%3A10.1038%2Fs41598-018-31202-1/MediaObjects/41598_2018_31202_Fig3_HTML.png){width="100%" fig-align="center"}
:::
:::

---

SBM is a *generative model* for networks with community structure.

It can generate networks with community structure.

![](https://docs.neurodata.io/graph-stats-book/_images/single-network-models_SBM_3_0.png){width="100%" fig-align="center"}

## Extensions of SBM

::: {.columns}
::: {.column width="60%"}
- SBM often produces homogeneous degree distributions when the number of communities is small, making it unsuitable for networks with heterogeneous degree distributions.

- **dcSBM** addresses this limitation, and often yields more meaningful communities than the standard SBM.

- **Hierarchical SBM (hSBM)**: Models communities within communities, capturing nested structures. This SBM is free from the resolution limit problem!

:::
::: {.column width="40%"}
![](https://d3i71xaburhd42.cloudfront.net/e8858c9f746239812b1512356ee9478158b9118a/15-Figure5-1.png){width="600" fig-align="center"}
:::
:::



## SBM Inference Methods

There are several ways to fit an SBM:

1.  **Maximum Likelihood Estimation (MLE)**: Fast, but can be prone to getting stuck in local optima.
2.  **Bayesian Inference**: More robust, can handle model selection (finding the number of blocks), but computationally expensive.
3.  **Spectral Methods**: Very fast, used for initialization.
4.  **Belief Propagation**: Fast and accurate on sparse, tree-like graphs.

## Which one should we use?

It depends on your network and your question!

- For a quick look, **Louvain/Leiden** (modularity-based) are fast and popular.
- For a more principled approach that can avoid some of modularity's pitfalls, **SBM** is a great choice.
- There is no "best" algorithm for all cases ("No Free Lunch" theorem).
- Always be critical of the communities you find!

## Further Reading

- Fortunato, S. (2010). Community detection in graphs. *Physics reports*, 486(3-5), 75-174.
- Peel, L., Larremore, D. B., & Clauset, A. (2017). The ground truth about metadata and community detection in networks. *Science advances*, 3(5), e1602548.
- Newman, M. E. (2016). Equivalence between modularity optimization and maximum likelihood methods for community detection. *Physical Review E*, 94(5), 052315.
- Hric, D., Peixoto, T. P., & Fortunato, S. (2016). Network structure, metadata, and the prediction of missing nodes and annotations. *Physical Review X*, 6(3), 031038.